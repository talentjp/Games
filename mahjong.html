<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Mahjong Solitaire</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a2e1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Critical for mobile 3D controls */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        .hud-panel {
            background: rgba(16, 34, 16, 0.85);
            color: #f0e6d2;
            padding: 12px 24px;
            border-radius: 12px;
            border: 2px solid #cdaf88;
            pointer-events: auto;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
        }
        h1 { margin: 0 0 5px 0; font-size: 1.1rem; color: #ffd700; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 0; font-size: 1rem; font-weight: bold; }
        
        #victory-modal, #error-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(16, 34, 16, 0.95);
            padding: 40px;
            border: 2px solid #ffd700;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 100;
            pointer-events: auto;
            min-width: 300px;
            box-shadow: 0 0 60px rgba(0,0,0,0.8);
        }
        #error-modal { border-color: red; color: #ffcccc; }
        
        button {
            background: linear-gradient(to bottom, #a31818, #7c0a0a);
            color: white;
            border: 1px solid #ff5555;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #4a0000;
        }
        button:active { transform: translateY(4px); box-shadow: none; }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none;
            background: rgba(0,0,0,0.6);
            padding: 20px 40px;
            border-radius: 50px;
            z-index: 50;
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
    <!-- Stable Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-panel">
            <h1>Mahjong 3D</h1>
            <p>Matches: <span id="matches">0</span></p>
            <p>Tiles Left: <span id="tiles-left">144</span></p>
        </div>
        <div class="hud-panel">
            <button onclick="Game.restart()" style="margin:0; font-size: 0.8rem; padding: 8px 16px; box-shadow: 0 2px 0 #440000;">Restart</button>
        </div>
    </div>

    <div id="victory-modal">
        <h1 style="font-size: 3rem; color: #ffd700;">VICTORY!</h1>
        <p>The board is clear.</p>
        <button onclick="Game.restart()">Play Again</button>
    </div>

    <div id="error-modal">
        <h1 style="color: red;">System Error</h1>
        <p id="error-msg">Something went wrong.</p>
        <button onclick="location.reload()">Reload Page</button>
    </div>

    <div id="loading">Building Board...</div>
    <div id="game-container"></div>

<script>
// Error Safety Net
window.onerror = function(msg, url, lineNo, columnNo, error) {
    document.getElementById('loading').style.display = 'none';
    document.getElementById('error-modal').style.display = 'block';
    document.getElementById('error-msg').innerText = msg;
    return false;
};

// --- CONFIG ---
const CONFIG = {
    TILE_W: 3,
    TILE_H: 4,
    TILE_D: 2,
    COLOR_BONE: '#fbfcf7',
    COLOR_BACK: 0x2e8b57, 
    COLOR_SIDE: 0xebe5ce
};

// --- TEXTURE GENERATOR ---
const TextureCache = {
    cache: {},
    getMaterial(type, value) {
        const key = type + "_" + value;
        if(this.cache[key]) return this.cache[key];
        
        const mat = this.generate(type, value);
        this.cache[key] = mat;
        return mat;
    },
    generate(type, value) {
        const cvs = document.createElement('canvas');
        cvs.width = 256; cvs.height = 342;
        const ctx = cvs.getContext('2d');
        const W = 256, H = 342;

        // Base
        ctx.fillStyle = CONFIG.COLOR_BONE;
        ctx.fillRect(0,0,W,H);
        
        // Noise
        ctx.fillStyle = "rgba(0,0,0,0.05)";
        for(let i=0; i<500; i++) ctx.fillRect(Math.random()*W, Math.random()*H, 2, 2);
        
        // Border
        ctx.strokeStyle = '#d5cbb0';
        ctx.lineWidth = 10;
        ctx.strokeRect(5,5,W-10,H-10);

        // Content
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        this.drawSymbol(ctx, type, value, W, H);

        const tex = new THREE.CanvasTexture(cvs);
        tex.anisotropy = 4;
        return new THREE.MeshStandardMaterial({ map: tex, roughness: 0.2, metalness: 0.1 });
    },
    drawSymbol(ctx, type, val, w, h) {
        // Simple robust drawing logic
        if(type === 'flower') {
            ctx.font = '100px serif'; ctx.fillText(['ðŸŒ¸','ðŸŒº','ðŸŒ¼','ðŸŒ»'][val], w/2, h/2);
            ctx.font = '30px sans-serif'; ctx.fillStyle='black'; ctx.fillText(val+1, w-30, 40);
            return;
        }
        if(type === 'season') {
            ctx.font = '100px serif'; ctx.fillText(['ðŸŒ±','â˜€ï¸','ðŸ','â„ï¸'][val], w/2, h/2);
            ctx.font = '30px sans-serif'; ctx.fillStyle='black'; ctx.fillText(val+1, w-30, 40);
            return;
        }
        if(type === 'dragon') {
            const col = ['#b22222', '#006400', '#191970'];
            const txt = ['ä¸­','ç™¼',' '];
            if(val===2) { ctx.strokeStyle='#191970'; ctx.lineWidth=6; ctx.strokeRect(w*0.2, h*0.1, w*0.6, h*0.8); }
            else { ctx.fillStyle=col[val]; ctx.font='bold 140px serif'; ctx.fillText(txt[val], w/2, h/2); }
            return;
        }
        if(type === 'wind') {
            ctx.fillStyle='black'; ctx.font='bold 140px serif';
            ctx.fillText(['æ±','å—','è¥¿','åŒ—'][val], w/2, h/2 - 20);
            ctx.font='40px sans-serif'; ctx.fillStyle='#555';
            ctx.fillText(['E','S','W','N'][val], w/2, h-50);
            return;
        }
        if(type === 'char') {
            const n = ['ä¸€','äºŒ','ä¸‰','å››','äº”','å…­','ä¸ƒ','å…«','ä¹'];
            ctx.fillStyle='black'; ctx.font='bold 80px serif'; ctx.fillText(n[val-1], w/2, h*0.35);
            ctx.fillStyle='#b22222'; ctx.font='bold 100px serif'; ctx.fillText('è¬', w/2, h*0.7);
            return;
        }
        if(type === 'bamboo') {
            if(val===1) { ctx.font='100px serif'; ctx.fillText('ðŸ¦', w/2, h/2); return; }
            this.drawPips(ctx, val, w, h, 'stick');
            return;
        }
        if(type === 'dot') {
            this.drawPips(ctx, val, w, h, 'dot');
            return;
        }
    },
    drawPips(ctx, val, w, h, shape) {
        // Simplified pip logic for robustness
        const R='#b22222', B='#191970', G='#006400';
        const pips = {
            1:[{x:0.5,y:0.5,c:R}],
            2:[{x:0.5,y:0.25,c:B},{x:0.5,y:0.75,c:B}],
            3:[{x:0.25,y:0.25,c:B},{x:0.5,y:0.5,c:R},{x:0.75,y:0.75,c:B}],
            4:[{x:0.25,y:0.25,c:B},{x:0.75,y:0.25,c:G},{x:0.25,y:0.75,c:G},{x:0.75,y:0.75,c:B}],
            5:[{x:0.25,y:0.25,c:B},{x:0.75,y:0.25,c:G},{x:0.5,y:0.5,c:R},{x:0.25,y:0.75,c:G},{x:0.75,y:0.75,c:B}],
            6:[{x:0.25,y:0.25,c:G},{x:0.75,y:0.25,c:G},{x:0.25,y:0.5,c:R},{x:0.75,y:0.5,c:R},{x:0.25,y:0.75,c:R},{x:0.75,y:0.75,c:R}],
            7:[{x:0.25,y:0.25,c:G},{x:0.75,y:0.25,c:G},{x:0.5,y:0.4,c:G},{x:0.25,y:0.6,c:R},{x:0.75,y:0.6,c:R},{x:0.25,y:0.8,c:R},{x:0.75,y:0.8,c:R}], // Simplified 7
            8:[{x:0.25,y:0.2,c:B},{x:0.75,y:0.2,c:B},{x:0.25,y:0.4,c:B},{x:0.75,y:0.4,c:B},{x:0.25,y:0.6,c:B},{x:0.75,y:0.6,c:B},{x:0.25,y:0.8,c:B},{x:0.75,y:0.8,c:B}],
            9:[{x:0.25,y:0.2,c:G},{x:0.5,y:0.2,c:G},{x:0.75,y:0.2,c:G},{x:0.25,y:0.5,c:R},{x:0.5,y:0.5,c:R},{x:0.75,y:0.5,c:R},{x:0.25,y:0.8,c:B},{x:0.5,y:0.8,c:B},{x:0.75,y:0.8,c:B}]
        };
        const set = pips[val] || [];
        set.forEach(p => {
            ctx.fillStyle = p.c;
            ctx.beginPath();
            if(shape==='dot') {
                ctx.arc(p.x*w, p.y*h, w*0.09, 0, Math.PI*2);
                ctx.fill();
            } else {
                ctx.strokeStyle = p.c;
                ctx.lineWidth = 10;
                ctx.moveTo(p.x*w, p.y*h - 15);
                ctx.lineTo(p.x*w, p.y*h + 15);
                ctx.stroke();
            }
        });
    }
};

// --- GAME LOGIC ---
const Game = {
    scene: null, camera: null, renderer: null, controls: null,
    raycaster: new THREE.Raycaster(), mouse: new THREE.Vector2(),
    tiles: [], tileData: [], selectedTile: null, matches: 0,
    touchStart: {x:0, y:0, time:0},
    
    // Materials
    matSide: new THREE.MeshStandardMaterial({ color: CONFIG.COLOR_SIDE }),
    matBack: new THREE.MeshStandardMaterial({ color: CONFIG.COLOR_BACK, roughness: 0.9 }),

    init() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a2e1a);
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 1, 1000);
        this.camera.position.set(0, 80, 50);
        this.camera.lookAt(0,0,0);
        
        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // Fix for HDPI displays (sharper text)
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('game-container').appendChild(this.renderer.domElement);

        // Lights
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dir = new THREE.DirectionalLight(0xfff5e6, 0.9);
        dir.position.set(20, 100, 50);
        dir.castShadow = true;
        dir.shadow.mapSize.width = 2048; 
        dir.shadow.mapSize.height = 2048;
        this.scene.add(dir);

        // Table
        const table = new THREE.Mesh(
            new THREE.PlaneGeometry(300, 300), 
            new THREE.MeshStandardMaterial({ color: 0x112211, roughness: 1 })
        );
        table.rotation.x = -Math.PI/2;
        table.position.y = -0.1;
        table.receiveShadow = true;
        this.scene.add(table);

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.maxPolarAngle = Math.PI/2.1;
        this.controls.minDistance = 20;
        this.controls.maxDistance = 150;

        // Events
        window.addEventListener('resize', () => this.onResize());
        
        // Unified Touch/Click Handling
        const canvas = this.renderer.domElement;
        
        // 1. Touch Start: Record pos & time
        canvas.addEventListener('touchstart', (e) => {
            this.touchStart.x = e.touches[0].clientX;
            this.touchStart.y = e.touches[0].clientY;
            this.touchStart.time = Date.now();
        }, {passive: false});

        // 2. Touch End: Check for tap vs drag
        canvas.addEventListener('touchend', (e) => {
            const dx = e.changedTouches[0].clientX - this.touchStart.x;
            const dy = e.changedTouches[0].clientY - this.touchStart.y;
            const dt = Date.now() - this.touchStart.time;
            
            // If movement is small and quick, it's a tap
            if (Math.abs(dx) < 10 && Math.abs(dy) < 10 && dt < 500) {
                // Prevent ghost mouse clicks
                e.preventDefault(); 
                this.handleTap(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        }, {passive: false});

        // 3. Mouse Click (Desktop fallback)
        canvas.addEventListener('click', (e) => {
            // Mouse clicks are simple
            this.handleTap(e.clientX, e.clientY);
        });

        this.restart();
        this.animate();
    },

    restart() {
        document.getElementById('loading').style.display = 'flex';
        
        // Short timeout to allow UI to render
        setTimeout(() => {
            this.clearBoard();
            const deck = this.generateDeck();
            const layout = this.generateTurtle();
            this.spawnTiles(deck, layout);
            this.matches = 0;
            this.updateUI();
            document.getElementById('loading').style.display = 'none';
            document.getElementById('victory-modal').style.display = 'none';
        }, 50);
    },

    clearBoard() {
        this.tiles.forEach(t => {
            this.scene.remove(t);
            t.geometry.dispose();
        });
        this.tiles = [];
        this.tileData = [];
        this.selectedTile = null;
    },

    generateDeck() {
        let d = [];
        // 4 of each
        const add = (t, count) => { for(let i=0; i<4; i++) for(let j=1; j<=count; j++) d.push({type:t, val:j}); };
        const addSimple = (t, max) => { for(let i=0; i<4; i++) for(let j=0; j<max; j++) d.push({type:t, val:j}); };
        
        add('dot', 9); add('bamboo', 9); add('char', 9);
        addSimple('wind', 4); addSimple('dragon', 3);
        // Flowers/Seasons (1 of each 4)
        for(let i=0; i<4; i++) d.push({type:'flower', val:i});
        for(let i=0; i<4; i++) d.push({type:'season', val:i});
        
        // Shuffle
        for (let i = d.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [d[i], d[j]] = [d[j], d[i]];
        }
        return d;
    },

    generateTurtle() {
        // Turtle Layout Logic
        let l = [];
        const add = (x, y, z) => l.push({x,y,z});
        
        // Level 0 (Bottom) - 8x10 block roughly
        for(let x=-3.5; x<=3.5; x++) for(let y=-3.5; y<=3.5; y++) add(x,y,0); // 64
        // Wings
        add(-4.5,0.5,0); add(-4.5,-0.5,0); add(-5.5,0.5,0); add(-5.5,-0.5,0); // Left 4
        add(4.5,0.5,0); add(4.5,-0.5,0); add(5.5,0.5,0); add(5.5,-0.5,0); // Right 4
        // Top/Bot Strips
        for(let x=-3.5; x<=3.5; x++) { add(x, -4.5, 0); add(x, 4.5, 0); } // 16
        
        // Level 1
        for(let x=-2.5; x<=2.5; x++) for(let y=-2.5; y<=2.5; y++) add(x,y,1); // 36
        
        // Level 2
        for(let x=-1.5; x<=1.5; x++) for(let y=-1.5; y<=1.5; y++) add(x,y,2); // 16
        
        // Level 3
        add(-0.5,-0.5,3); add(0.5,-0.5,3); add(-0.5,0.5,3); add(0.5,0.5,3); // 4
        
        // Level 4 (Top)
        add(0,0,4); // 1
        
        // Total so far: 145? Need 144. 
        // My manual count might be slightly off, let's just truncate 'l' to 144 in spawn
        return l;
    },

    spawnTiles(deck, layout) {
        const geo = new THREE.BoxGeometry(CONFIG.TILE_W, CONFIG.TILE_H, CONFIG.TILE_D);
        const count = Math.min(deck.length, layout.length);
        
        for(let i=0; i<count; i++) {
            const pos = layout[i];
            const info = deck[i];
            const matFace = TextureCache.getMaterial(info.type, info.val);
            
            const mesh = new THREE.Mesh(geo, [
                this.matSide, this.matSide, this.matSide, this.matSide,
                matFace, this.matBack
            ]);
            
            mesh.rotation.x = -Math.PI / 2;
            
            // Positioning
            // x: Grid X * Width
            // y: Grid Z * Thickness (Height)
            // z: Grid Y * Length (Depth)
            mesh.position.set(
                pos.x * (CONFIG.TILE_W - 0.1), // Tight pack X
                (pos.z * CONFIG.TILE_D) + CONFIG.TILE_D/2,
                pos.y * (CONFIG.TILE_H - 0.1)  // Tight pack Z
            );
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // User Data for logic
            mesh.userData = {
                id: i,
                ...info,
                gx: pos.x, gy: pos.y, gz: pos.z,
                baseY: mesh.position.y
            };
            
            this.scene.add(mesh);
            this.tiles.push(mesh);
            this.tileData.push(mesh.userData);
        }
    },

    handleTap(clientX, clientY) {
        // Raycast
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.tiles);
        
        if (intersects.length > 0) {
            // Get the first hit
            const tile = intersects[0].object;
            this.clickTile(tile);
        } else {
            this.deselect();
        }
    },

    clickTile(tile) {
        // Logic Check
        if (!this.isFree(tile.userData)) {
            this.shakeTile(tile); // Visual Feedback
            return;
        }

        if (this.selectedTile === tile) {
            this.deselect();
        } else if (this.selectedTile) {
            // Match attempt
            if (this.isMatch(this.selectedTile.userData, tile.userData)) {
                this.removePair(this.selectedTile, tile);
                this.selectedTile = null;
            } else {
                this.deselect();
                this.select(tile);
            }
        } else {
            this.select(tile);
        }
    },

    isFree(d) {
        // Top Check
        for(let o of this.tileData) {
            if (o.id === d.id) continue;
            // Is it directly above?
            if (o.gz === d.gz + 1) {
                // Check overlap
                if (Math.abs(o.gx - d.gx) < 0.9 && Math.abs(o.gy - d.gy) < 0.9) return false;
            }
        }
        
        // Side Check
        let leftBlocked = false;
        let rightBlocked = false;
        
        for(let o of this.tileData) {
            if (o.id === d.id) continue;
            if (o.gz !== d.gz) continue; // Must be same level
            
            // Must be adjacent in Y
            if (Math.abs(o.gy - d.gy) < 0.9) {
                // Is it left? (gx is roughly d.gx - 1)
                if (Math.abs(o.gx - (d.gx - 1)) < 0.2) leftBlocked = true;
                if (Math.abs(o.gx - (d.gx - 0.5)) < 0.1) leftBlocked = true; // Handle half steps
                
                // Is it right?
                if (Math.abs(o.gx - (d.gx + 1)) < 0.2) rightBlocked = true;
                if (Math.abs(o.gx - (d.gx + 0.5)) < 0.1) rightBlocked = true;
            }
        }
        
        // Free if Left OR Right is empty
        if (leftBlocked && rightBlocked) return false;
        return true;
    },

    isMatch(a, b) {
        if (a.id === b.id) return false;
        if (a.type !== b.type) return false;
        if (a.type === 'flower' || a.type === 'season') return true;
        return a.val === b.val;
    },

    select(tile) {
        this.selectedTile = tile;
        new TWEEN.Tween(tile.position).to({ y: tile.userData.baseY + 0.8 }, 150).start();
        tile.material[4].emissive.setHex(0x444444);
    },

    deselect() {
        if(this.selectedTile) {
            const t = this.selectedTile;
            new TWEEN.Tween(t.position).to({ y: t.userData.baseY }, 150).start();
            t.material[4].emissive.setHex(0x000000);
            this.selectedTile = null;
        }
    },

    shakeTile(tile) {
        // "Nope" animation
        const x = tile.position.x;
        tile.material[4].emissive.setHex(0x550000); // Red flash
        new TWEEN.Tween(tile.position)
            .to({ x: x - 0.3 }, 50)
            .yoyo(true).repeat(3)
            .onComplete(() => {
                tile.position.x = x;
                tile.material[4].emissive.setHex(0x000000);
            })
            .start();
    },

    removePair(t1, t2) {
        // Shrink away
        const kill = (t) => {
            new TWEEN.Tween(t.scale).to({x:0, y:0, z:0}, 300).easing(TWEEN.Easing.Back.In)
            .onComplete(() => {
                this.scene.remove(t);
                t.geometry.dispose();
            }).start();
        };
        kill(t1); kill(t2);
        
        // Update Data
        this.tileData = this.tileData.filter(d => d.id !== t1.userData.id && d.id !== t2.userData.id);
        this.tiles = this.tiles.filter(m => m !== t1 && m !== t2);
        
        this.matches++;
        this.updateUI();
        
        if(this.tileData.length === 0) document.getElementById('victory-modal').style.display='block';
    },

    updateUI() {
        document.getElementById('matches').innerText = this.matches;
        document.getElementById('tiles-left').innerText = this.tileData.length;
    },

    onResize() {
        this.camera.aspect = window.innerWidth/window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    },

    animate(time) {
        requestAnimationFrame((t) => this.animate(t));
        TWEEN.update(time);
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
};

Game.init();
</script>
</body>
</html>

