<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Defender FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevent browser zooming/scrolling */
        }

        /* UI Overlay */
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            color: #fff;
            text-align: center;
        }

        #instructions {
            font-size: 24px;
            cursor: pointer;
            text-shadow: 0 0 10px #0ff;
            padding: 20px;
        }

        #title {
            font-size: 60px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #00f;
            margin-bottom: 20px;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none; /* Hidden until play */
        }

        .hud-element {
            position: absolute;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        #health-bar-container {
            bottom: 30px;
            left: 30px;
            width: 200px;
            height: 20px;
            background: rgba(50, 50, 50, 0.5);
            border: 2px solid #fff;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #0f0;
            transition: width 0.2s, background-color 0.2s;
        }

        #score-display {
            top: 20px;
            right: 30px;
            font-size: 30px;
            color: #ff0;
        }

        #wave-display {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #0ff;
        }

        #ammo-display {
            bottom: 30px;
            right: 30px;
            font-size: 40px;
            color: #fff;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
        }

        /* Hit marker effect */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.5) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
        }

        /* --- Mobile Controls --- */
        #mobile-controls {
            display: none; /* Enabled via JS or Media Query */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .mobile-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #0ff;
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            user-select: none;
            touch-action: none;
        }
        
        .mobile-btn:active {
            background: rgba(0, 255, 255, 0.4);
        }

        #shoot-btn {
            bottom: 80px;
            right: 30px;
            width: 90px;
            height: 90px;
            border-color: #ff0;
            font-size: 18px;
        }

        #jump-btn {
            bottom: 190px;
            right: 40px;
        }

        #reload-btn {
            top: 80px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-color: #f0f;
            font-size: 12px;
        }

        /* Virtual Joystick */
        #joystick-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
            z-index: 4;
        }

        #look-zone {
            position: absolute;
            top: 0;
            left: 50%;
            width: 50%;
            height: 100%;
            pointer-events: auto;
            z-index: 4;
        }

        #joystick-base {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: none;
            pointer-events: none;
        }

        #joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Show mobile controls on touch devices */
        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: block; }
            #health-bar-container { bottom: unset; top: 20px; left: 20px; width: 150px; }
            #wave-display { top: 60px; font-size: 18px; }
            #score-display { display: none; } /* Simplify HUD on mobile */
            #ammo-display { bottom: unset; top: 20px; right: 100px; font-size: 24px; }
            #title { font-size: 40px; }
        }
    </style>
</head>
<body>

    <!-- UI Elements -->
    <div id="blocker">
        <div id="title">NEON DEFENDER</div>
        <div id="instructions">
            CLICK / TAP TO START<br/><br/>
            Desktop: WASD + Mouse<br/>
            Mobile: Left Side Move, Right Side Aim
        </div>
    </div>

    <div id="hud">
        <div id="crosshair">
            <svg width="20" height="20" viewBox="0 0 20 20">
                <circle cx="10" cy="10" r="2" fill="#0ff" />
                <line x1="0" y1="10" x2="6" y2="10" stroke="#0ff" stroke-width="2" />
                <line x1="14" y1="10" x2="20" y2="10" stroke="#0ff" stroke-width="2" />
                <line x1="10" y1="0" x2="10" y2="6" stroke="#0ff" stroke-width="2" />
                <line x1="10" y1="14" x2="10" y2="20" stroke="#0ff" stroke-width="2" />
            </svg>
        </div>
        <div id="health-bar-container" class="hud-element">
            <div id="health-bar"></div>
        </div>
        <div id="score-display" class="hud-element">SCORE: 0</div>
        <div id="wave-display" class="hud-element">WAVE: 1</div>
        <div id="ammo-display" class="hud-element">20 / ∞</div>
        <div id="damage-overlay"></div>

        <!-- Mobile Controls Overlay -->
        <div id="joystick-zone"></div> <!-- Invisible touch zone for movement -->
        <div id="look-zone"></div>     <!-- Invisible touch zone for looking -->
        
        <div id="mobile-controls">
            <div id="joystick-base">
                <div id="joystick-stick"></div>
            </div>
            <div id="reload-btn" class="mobile-btn">RELOAD</div>
            <div id="jump-btn" class="mobile-btn">JUMP</div>
            <div id="shoot-btn" class="mobile-btn">SHOOT</div>
        </div>
    </div>

    <!-- Import Map (ES Modules for Three.js) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const PLAYER_HEIGHT = 1.6;
        const PLAYER_SPEED = 10.0;
        const PLAYER_JUMP_FORCE = 15.0;
        const GRAVITY = 30.0;
        const BULLET_SPEED = 60;
        const ENEMY_SPEED = 4;
        const MAX_AMMO = 20;

        // --- Global Variables ---
        let camera, scene, renderer, controls;
        
        // Game State
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isGameActive = false;
        
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Mobile Controls State
        let joystickVector = { x: 0, y: 0 };
        let touchLookVector = { x: 0, y: 0 };
        let touchIdMove = null;
        let touchIdLook = null;
        let lastLookX = 0;
        let lastLookY = 0;

        // Game Objects
        let bullets = [];
        let enemies = [];
        let particles = []; 
        let gunModel;
        let muzzleLight;

        // Player Stats
        let score = 0;
        let health = 100;
        let wave = 1;
        let ammo = MAX_AMMO;
        let isReloading = false;
        
        // Audio Context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // UI References
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const hud = document.getElementById('hud');
        const healthBar = document.getElementById('health-bar');
        const scoreDisplay = document.getElementById('score-display');
        const waveDisplay = document.getElementById('wave-display');
        const ammoDisplay = document.getElementById('ammo-display');
        const damageOverlay = document.getElementById('damage-overlay');

        // Mobile UI
        const joystickZone = document.getElementById('joystick-zone');
        const lookZone = document.getElementById('look-zone');
        const joystickBase = document.getElementById('joystick-base');
        const joystickStick = document.getElementById('joystick-stick');
        const shootBtn = document.getElementById('shoot-btn');
        const jumpBtn = document.getElementById('jump-btn');
        const reloadBtn = document.getElementById('reload-btn');

        init();
        animate();

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.Fog(0x050510, 0, 70);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            // 3. Lighting
            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(50, 200, 100);
            scene.add(dirLight);

            // 4. Controls
            controls = new PointerLockControls(camera, document.body);

            // Desktop Start
            instructions.addEventListener('click', () => {
                controls.lock();
            });

            // Mobile Start
            instructions.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent ghost clicks
                startGameMobile();
            }, { passive: false });

            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                hud.style.display = 'block';
                isGameActive = true;
                if (audioCtx.state === 'suspended') audioCtx.resume();
            });

            controls.addEventListener('unlock', () => {
                // Only pause if we aren't in mobile mode (mobile mode doesn't use pointer lock)
                // We detect mobile mode by checking if we have touch events active
                if (!isMobileDevice()) {
                    blocker.style.display = 'flex';
                    instructions.style.display = 'block';
                    instructions.innerHTML = "PAUSED<br/><br/>Click to Resume";
                    hud.style.display = 'none';
                    isGameActive = false;
                }
            });

            scene.add(controls.getObject());

            // 5. Input Listeners (Keyboard)
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space':
                        if (canJump === true) velocity.y += PLAYER_JUMP_FORCE;
                        canJump = false;
                        break;
                    case 'KeyR': reload(); break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', (e) => {
                // Only shoot on mouse click if not touching a UI button
                if(isGameActive && e.button === 0 && !e.target.classList.contains('mobile-btn')) shoot();
            });

            // 6. Mobile Input Listeners
            setupMobileControls();

            // 7. World Generation
            createLevel();
            createGun();

            // 8. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
            
            // Start Enemy Spawner
            setInterval(spawnEnemy, 2000);
        }

        function startGameMobile() {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
            hud.style.display = 'block';
            isGameActive = true;
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function isMobileDevice() {
            return (('ontouchstart' in window) ||
               (navigator.maxTouchPoints > 0) ||
               (navigator.msMaxTouchPoints > 0));
        }

        function setupMobileControls() {
            // Joystick Logic
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                touchIdMove = touch.identifier;
                
                // Show visual joystick
                joystickBase.style.display = 'block';
                joystickBase.style.left = (touch.clientX - 50) + 'px';
                joystickBase.style.top = (touch.clientY - 50) + 'px';
                joystickStick.style.transform = `translate(-50%, -50%)`;
                
                joystickVector.x = 0;
                joystickVector.y = 0;
            }, { passive: false });

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchIdMove) {
                        const touch = e.changedTouches[i];
                        const baseX = parseFloat(joystickBase.style.left) + 50;
                        const baseY = parseFloat(joystickBase.style.top) + 50;
                        
                        let dx = touch.clientX - baseX;
                        let dy = touch.clientY - baseY;
                        
                        // Clamp visual
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const maxDist = 40;
                        if (distance > maxDist) {
                            const ratio = maxDist / distance;
                            dx *= ratio;
                            dy *= ratio;
                        }

                        joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                        
                        // Normalize output -1 to 1
                        joystickVector.x = dx / maxDist;
                        joystickVector.y = dy / maxDist;
                    }
                }
            }, { passive: false });

            const endJoystick = (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchIdMove) {
                        touchIdMove = null;
                        joystickBase.style.display = 'none';
                        joystickVector.x = 0;
                        joystickVector.y = 0;
                    }
                }
            };
            joystickZone.addEventListener('touchend', endJoystick);
            joystickZone.addEventListener('touchcancel', endJoystick);

            // Look Logic
            lookZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                touchIdLook = touch.identifier;
                lastLookX = touch.clientX;
                lastLookY = touch.clientY;
            }, { passive: false });

            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchIdLook) {
                        const touch = e.changedTouches[i];
                        const dx = touch.clientX - lastLookX;
                        const dy = touch.clientY - lastLookY;
                        
                        // Update Look Vector (consumed in animate)
                        touchLookVector.x += dx;
                        touchLookVector.y += dy;
                        
                        lastLookX = touch.clientX;
                        lastLookY = touch.clientY;
                    }
                }
            }, { passive: false });

            const endLook = (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchIdLook) {
                        touchIdLook = null;
                    }
                }
            };
            lookZone.addEventListener('touchend', endLook);
            
            // Buttons
            shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); }, { passive: false });
            jumpBtn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                if (canJump === true) velocity.y += PLAYER_JUMP_FORCE;
                canJump = false;
            }, { passive: false });
            reloadBtn.addEventListener('touchstart', (e) => { e.preventDefault(); reload(); }, { passive: false });
        }

        function createLevel() {
            // Floor - Tron Grid
            const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x222222);
            scene.add(gridHelper);

            // Floor Plane
            const floorGeometry = new THREE.PlaneGeometry(200, 200, 100, 100);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x050510 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = - Math.PI / 2;
            scene.add(floor);

            // Random Boxes/Obstacles
            const boxGeo = new THREE.BoxGeometry(5, 5, 5);
            const boxMat = new THREE.MeshPhongMaterial({ color: 0x444444, specular: 0x111111 });
            const edgesGeo = new THREE.EdgesGeometry(boxGeo);
            const edgesMat = new THREE.LineBasicMaterial({ color: 0x00ffff });

            for (let i = 0; i < 20; i++) {
                const box = new THREE.Mesh(boxGeo, boxMat);
                let x = Math.random() * 100 - 50;
                let z = Math.random() * 100 - 50;
                if (Math.abs(x) < 10 && Math.abs(z) < 10) { x += 20; }

                box.position.x = x;
                box.position.y = 2.5; 
                box.position.z = z;
                
                const edges = new THREE.LineSegments(edgesGeo, edgesMat);
                box.add(edges);

                scene.add(box);
            }
        }

        function createGun() {
            gunModel = new THREE.Group();
            
            // Gun Body
            const bodyGeo = new THREE.BoxGeometry(0.15, 0.2, 0.6);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.set(0, 0, 0);
            gunModel.add(body);

            // Barrel (Neon)
            const barrelGeo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
            const barrelMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.position.set(0, 0.1, -0.3);
            gunModel.add(barrel);

            // Muzzle Flash Light
            muzzleLight = new THREE.PointLight(0x00ffff, 0, 5);
            muzzleLight.position.set(0, 0.1, -0.6);
            gunModel.add(muzzleLight);

            camera.add(gunModel);
            gunModel.position.set(0.3, -0.3, -0.5);
        }

        function createSound(type) {
            if (audioCtx.state === 'suspended') return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            } else if (type === 'hit') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100, now);
                oscillator.frequency.exponentialRampToValueAtTime(10, now + 0.1);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            } else if (type === 'enemy_death') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
        }

        function shoot() {
            if (ammo <= 0 || isReloading) return;

            ammo--;
            updateHUD();
            createSound('shoot');

            gunModel.position.z += 0.2;
            muzzleLight.intensity = 5;
            setTimeout(() => { muzzleLight.intensity = 0; }, 50);

            // Visual Bullet
            const bulletGeo = new THREE.SphereGeometry(0.05);
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            const worldPos = new THREE.Vector3();
            gunModel.children[1].getWorldPosition(worldPos); 
            bullet.position.copy(worldPos);
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            bullet.userData = { velocity: direction.multiplyScalar(BULLET_SPEED) };
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        function reload() {
            if (ammo === MAX_AMMO || isReloading) return;
            isReloading = true;
            ammoDisplay.textContent = "RELOADING...";
            
            const originalRot = gunModel.rotation.x;
            
            let reloadInterval = setInterval(() => {
                gunModel.rotation.x -= 0.1;
            }, 50);

            setTimeout(() => {
                clearInterval(reloadInterval);
                ammo = MAX_AMMO;
                isReloading = false;
                updateHUD();
                gunModel.rotation.x = originalRot;
                gunModel.position.set(0.3, -0.3, -0.5);
            }, 1000);
        }

        function spawnEnemy() {
            if (!isGameActive || enemies.length > 5 + wave) return;

            const geometry = new THREE.IcosahedronGeometry(1, 0);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xff0000, 
                emissive: 0xaa0000,
                emissiveIntensity: 0.5,
                shininess: 100,
                flatShading: true 
            });
            const enemy = new THREE.Mesh(geometry, material);

            const angle = Math.random() * Math.PI * 2;
            const radius = 40 + Math.random() * 20;
            enemy.position.x = Math.cos(angle) * radius;
            enemy.position.z = Math.sin(angle) * radius;
            enemy.position.y = 1;

            enemy.userData = { 
                health: 3, 
                speed: ENEMY_SPEED + (wave * 0.2) 
            };

            scene.add(enemy);
            enemies.push(enemy);
        }

        function createExplosion(position, color) {
            const particleCount = 10;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            for(let i=0; i<particleCount; i++) {
                positions.push(position.x, position.y, position.z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.5,
                transparent: true
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            
            const velocities = [];
            for(let i=0; i<particleCount; i++) {
                velocities.push({
                    x: (Math.random() - 0.5) * 10,
                    y: (Math.random() - 0.5) * 10,
                    z: (Math.random() - 0.5) * 10
                });
            }
            particleSystem.userData = { velocities: velocities, age: 0 };
            
            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        function updateHUD() {
            healthBar.style.width = Math.max(0, health) + '%';
            if (health > 50) healthBar.style.backgroundColor = '#0f0';
            else if (health > 25) healthBar.style.backgroundColor = '#ff0';
            else healthBar.style.backgroundColor = '#f00';

            scoreDisplay.textContent = `SCORE: ${score}`;
            waveDisplay.textContent = `WAVE: ${wave}`;
            ammoDisplay.textContent = `${ammo} / ∞`;
        }

        function gameOver() {
            isGameActive = false;
            // Show start screen again
            blocker.style.display = 'flex';
            instructions.style.display = 'block';
            instructions.innerHTML = `GAME OVER<br/>Score: ${score}<br/>Wave: ${wave}<br/><br/>Tap to Restart`;
            
            // Unlock pointer if using desktop
            if(!isMobileDevice()) controls.unlock();
            
            // Reset Game
            score = 0;
            health = 100;
            wave = 1;
            ammo = MAX_AMMO;
            
            enemies.forEach(e => scene.remove(e));
            enemies = [];
            bullets.forEach(b => scene.remove(b));
            bullets = [];
            
            updateHUD();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isGameActive) {
                renderer.render(scene, camera);
                return;
            }

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            // --- Camera Rotation (Mobile) ---
            if (Math.abs(touchLookVector.x) > 0 || Math.abs(touchLookVector.y) > 0) {
                const sensitivity = 0.002;
                // Rotate the camera object (which is wrapped by PointerLockControls)
                controls.getObject().rotation.y -= touchLookVector.x * sensitivity;
                
                // Pitch (up/down) is trickier with Euler, but modifying rotation.x works if Order is YXZ
                // PointerLockControls usually ensures YXZ.
                // NOTE: PointerLockControls internally accumulates rotation in .rotation.
                // We access the camera directly via controls.getObject()
                
                // We need to implement clamp for Pitch
                const pitch = controls.getObject().rotation.x - (touchLookVector.y * sensitivity);
                controls.getObject().rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                
                touchLookVector.x = 0;
                touchLookVector.y = 0;
            }

            // --- Player Movement Physics ---
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= GRAVITY * delta; 

            // Input mixing (Keyboard OR Joystick)
            const inputFwd = (moveForward ? 1 : 0) - (moveBackward ? 1 : 0) - joystickVector.y;
            const inputRight = (moveRight ? 1 : 0) - (moveLeft ? 1 : 0) + joystickVector.x;

            direction.z = inputFwd;
            direction.x = inputRight;
            direction.normalize(); 

            if (Math.abs(inputFwd) > 0 || Math.abs(inputRight) > 0) {
                 velocity.z -= direction.z * PLAYER_SPEED * 40.0 * delta;
                 velocity.x -= direction.x * PLAYER_SPEED * 40.0 * delta;
            }

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            controls.getObject().position.y += (velocity.y * delta);

            // Floor Collision
            if (controls.getObject().position.y < PLAYER_HEIGHT) {
                velocity.y = 0;
                controls.getObject().position.y = PLAYER_HEIGHT;
                canJump = true;
            }

            if (gunModel) {
                gunModel.position.z = THREE.MathUtils.lerp(gunModel.position.z, -0.5, 0.1);
            }

            // --- Update Bullets ---
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.addScaledVector(b.userData.velocity, delta);

                if (b.position.distanceTo(controls.getObject().position) > 100) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.position.distanceTo(e.position) < 1.5) { 
                        
                        createSound('hit');
                        createExplosion(b.position, 0xffff00);
                        
                        e.userData.health--;
                        e.material.emissive.setHex(0xffffff);
                        setTimeout(() => { if(e) e.material.emissive.setHex(0xaa0000); }, 50);

                        if (e.userData.health <= 0) {
                            createSound('enemy_death');
                            createExplosion(e.position, 0xff0000);
                            scene.remove(e);
                            enemies.splice(j, 1);
                            score += 10;
                            if (score % 100 === 0) {
                                wave++;
                                health = Math.min(100, health + 20); 
                            }
                            updateHUD();
                        }

                        scene.remove(b);
                        bullets.splice(i, 1);
                        break; 
                    }
                }
            }

            // --- Update Enemies ---
            const playerPos = controls.getObject().position;
            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                e.lookAt(playerPos);
                e.translateZ(e.userData.speed * delta);
                e.position.y = 1 + Math.sin(time * 0.005 + i) * 0.5;

                if (e.position.distanceTo(playerPos) < 2) {
                    health -= 1; 
                    updateHUD();
                    
                    damageOverlay.style.opacity = 0.5;
                    setTimeout(() => { damageOverlay.style.opacity = 0; }, 100);

                    if (health <= 0) {
                        gameOver();
                    }
                }
            }

            // --- Update Particles ---
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const positions = p.geometry.attributes.position.array;
                const vels = p.userData.velocities;
                
                for(let j=0; j<vels.length; j++) {
                    positions[j*3] += vels[j].x * delta;
                    positions[j*3+1] += vels[j].y * delta;
                    positions[j*3+2] += vels[j].z * delta;
                }
                p.geometry.attributes.position.needsUpdate = true;
                p.material.opacity -= 2.0 * delta;
                
                if (p.material.opacity <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
