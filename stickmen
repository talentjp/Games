<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stickman Sandbox</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f3f4f6;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        .tool-btn {
            transition: all 0.1s;
        }
        .tool-btn:active {
            transform: scale(0.95);
        }
        .tool-btn.active {
            background-color: #3b82f6;
            color: white;
            border-color: #2563eb;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        }
        /* Shake animation for damage */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake {
            animation: shake 0.5s;
            animation-iteration-count: 1;
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 w-full p-2 flex justify-between items-start pointer-events-none">
        <div class="bg-white/90 backdrop-blur-sm p-3 rounded-xl shadow-lg border border-gray-200 pointer-events-auto">
            <h1 class="text-lg font-bold text-gray-800 leading-none">Stickman Sandbox</h1>
            <p class="text-xs text-gray-500 mt-1">Spawn 'em and smash 'em.</p>
            <div class="mt-2 text-xs font-mono text-gray-600">
                Count: <span id="entityCount">0</span>
            </div>
        </div>
        
        <div class="bg-white/90 backdrop-blur-sm p-2 rounded-xl shadow-lg border border-gray-200 pointer-events-auto flex flex-col gap-2">
            <button onclick="clearAll()" class="bg-red-100 hover:bg-red-200 text-red-600 px-3 py-1 rounded text-xs font-bold transition-colors">
                Clear All
            </button>
             <button onclick="resetCamera()" class="bg-gray-100 hover:bg-gray-200 text-gray-600 px-3 py-1 rounded text-xs font-bold transition-colors">
                Reset Cam
            </button>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 w-[95%] max-w-2xl bg-white/90 backdrop-blur-md p-2 rounded-2xl shadow-xl border border-gray-200 flex overflow-x-auto gap-2 pointer-events-auto no-scrollbar" style="scrollbar-width: none;">
        
        <!-- Tools generated by JS -->
        <button id="tool-hand" onclick="selectTool('hand')" class="tool-btn active flex-shrink-0 flex flex-col items-center justify-center w-16 h-16 rounded-xl border-2 border-transparent hover:bg-gray-100 text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>
            <span class="text-[10px] font-bold mt-1">Grab</span>
        </button>

        <button id="tool-spawn" onclick="selectTool('spawn')" class="tool-btn flex-shrink-0 flex flex-col items-center justify-center w-16 h-16 rounded-xl border-2 border-transparent hover:bg-gray-100 text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
            <span class="text-[10px] font-bold mt-1">Spawn</span>
        </button>

        <button id="tool-bomb" onclick="selectTool('bomb')" class="tool-btn flex-shrink-0 flex flex-col items-center justify-center w-16 h-16 rounded-xl border-2 border-transparent hover:bg-gray-100 text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="m22 2-7 7"/><path d="M11 9v6"/><path d="m8.5 10.5 7 3"/><path d="m8.5 13.5 7-3"/></svg>
            <span class="text-[10px] font-bold mt-1">Bomb</span>
        </button>

        <button id="tool-gun" onclick="selectTool('gun')" class="tool-btn flex-shrink-0 flex flex-col items-center justify-center w-16 h-16 rounded-xl border-2 border-transparent hover:bg-gray-100 text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 19h3v-7h15v-5h-4l-3-4h-8v4h-3z"/><circle cx="8.5" cy="13.5" r=".5"/></svg>
            <span class="text-[10px] font-bold mt-1">Pistol</span>
        </button>
        
        <button id="tool-smash" onclick="selectTool('smash')" class="tool-btn flex-shrink-0 flex flex-col items-center justify-center w-16 h-16 rounded-xl border-2 border-transparent hover:bg-gray-100 text-gray-600">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h1"/><path d="M12 3v1"/><path d="M20 12h1"/><path d="M12 20v1"/><path d="M5.6 5.6l.7.7"/><path d="M18.4 5.6l-.7.7"/><path d="M17.7 17.7l.7.7"/><path d="M6.3 17.7l-.7.7"/><path d="M12 7a5 5 0 1 0 0 10 5 5 0 0 0 0-10Z"/></svg>
            <span class="text-[10px] font-bold mt-1">Smash</span>
        </button>

        <button id="tool-mine" onclick="selectTool('mine')" class="tool-btn flex-shrink-0 flex flex-col items-center justify-center w-16 h-16 rounded-xl border-2 border-transparent hover:bg-gray-100 text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v20"/><path d="M2 12h20"/><circle cx="12" cy="12" r="4"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/><path d="m6.34 17.66-1.41 1.41"/></svg>
            <span class="text-[10px] font-bold mt-1">Mine</span>
        </button>

         <button id="tool-blackhole" onclick="selectTool('blackhole')" class="tool-btn flex-shrink-0 flex flex-col items-center justify-center w-16 h-16 rounded-xl border-2 border-transparent hover:bg-gray-100 text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 12 8 8"/><path d="M12 12 8 16"/><path d="M12 12 16 16"/><path d="M12 12 16 8"/></svg>
            <span class="text-[10px] font-bold mt-1">Void</span>
        </button>
    </div>

    <script>
        // --- Game Engine & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const entityCountDisplay = document.getElementById('entityCount');
        
        // Configuration
        const GRAVITY = 0.5;
        const FRICTION = 0.85; // Air resistance
        const GROUND_FRICTION = 0.8;
        const WALL_BOUNCE = -0.5;
        const SPAWN_RATE = 5; // Frames between auto spawns initially

        let entities = [];
        let particles = [];
        let currentTool = 'hand';
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let cameraX = 0;
        let cameraY = 0;
        
        // Grab logic
        let grabbedEntity = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let mouseVx = 0;
        let mouseVy = 0;

        // Resize Canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Classes ---

        class Entity {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.radius = 10;
                this.color = '#333';
                this.dead = false;
                this.grounded = false;
                this.hp = 100;
                this.maxHp = 100;
                this.type = 'base';
                this.rotation = 0;
                this.vRotation = 0;
            }

            update() {
                // Physics
                this.vy += GRAVITY;
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.vRotation;
                this.vRotation *= 0.9;

                // Floor Collision
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= WALL_BOUNCE;
                    this.vx *= GROUND_FRICTION;
                    this.grounded = true;
                    this.vRotation *= 0.8; // Stop spinning on ground
                } else {
                    this.grounded = false;
                }

                // Wall Collision
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= WALL_BOUNCE;
                }
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= WALL_BOUNCE;
                }

                // Ceiling
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= WALL_BOUNCE;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }

            takeDamage(amount, sourceX, sourceY, force) {
                this.hp -= amount;
                
                // Knockback
                if (sourceX !== undefined) {
                    const dx = this.x - sourceX;
                    const dy = this.y - sourceY;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    this.vx += (dx / dist) * force;
                    this.vy += (dy / dist) * force;
                    this.vRotation += (Math.random() - 0.5) * 0.5; // Add spin
                }

                // Blood particles
                for(let i=0; i<3; i++) {
                    particles.push(new Particle(this.x, this.y, 'rgba(220, 38, 38, 0.8)', 2 + Math.random()*2));
                }

                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                this.dead = true;
                // Explosion of parts
                for(let i=0; i<8; i++) {
                     particles.push(new Particle(this.x, this.y, this.color, 4));
                }
            }
        }

        class Stickman extends Entity {
            constructor(x, y) {
                super(x, y);
                this.type = 'stickman';
                this.radius = 15; // Hitbox size
                this.walkCycle = 0;
                this.walkSpeed = 0.1 + Math.random() * 0.1;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.moveTimer = 0;
                this.headColor = '#1f2937';
                this.bodyColor = '#1f2937';
                
                // Limbs state
                this.legAngle = 0;
                this.armAngle = 0;
                this.panic = false;
            }

            update() {
                super.update();

                if (this.dead) return;

                // AI Logic
                if (this.grounded && !grabbedEntity && !this.panic) {
                    // Random walking
                    this.moveTimer++;
                    if (this.moveTimer > 100) {
                        this.direction = Math.random() > 0.5 ? 1 : -1;
                        this.moveTimer = 0 - Math.random() * 100; // Pause sometimes
                    }

                    if (this.moveTimer > 0) {
                        this.vx += this.direction * 0.5;
                        // Cap speed
                        if (this.vx > 3) this.vx = 3;
                        if (this.vx < -3) this.vx = -3;
                        
                        this.walkCycle += this.walkSpeed * Math.abs(this.vx);
                    } else {
                        // Standing still
                        this.walkCycle = 0;
                    }
                } else if (!this.grounded) {
                    // Flail in air
                    this.walkCycle += 0.5;
                }

                // Orientation logic
                if (Math.abs(this.rotation) > 0.1 && this.grounded) {
                    this.rotation += -this.rotation * 0.1; // Try to stand up
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Style based on HP
                const hpRatio = this.hp / this.maxHp;
                ctx.strokeStyle = this.bodyColor;
                ctx.fillStyle = this.headColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Injured effect
                if (hpRatio < 0.5) ctx.strokeStyle = '#991b1b'; // Dark red
                
                // Animation calculations
                const legSwing = Math.sin(this.walkCycle) * 10;
                const armSwing = Math.cos(this.walkCycle) * 10;

                // Draw Body (Simplified Skeleton)
                // Head
                ctx.beginPath();
                ctx.arc(0, -20, 8, 0, Math.PI * 2);
                ctx.fill();
                // Eyes (X if dead or low health)
                if (this.hp < 20 || this.dead) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    // Left Eye
                    ctx.moveTo(-3, -22); ctx.lineTo(-1, -20);
                    ctx.moveTo(-1, -22); ctx.lineTo(-3, -20);
                    // Right Eye
                    ctx.moveTo(1, -22); ctx.lineTo(3, -20);
                    ctx.moveTo(3, -22); ctx.lineTo(1, -20);
                    ctx.stroke();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = this.hp < 0.5 ? '#991b1b' : '#1f2937';
                }

                // Torso
                ctx.beginPath();
                ctx.moveTo(0, -12);
                ctx.lineTo(0, 10);
                ctx.stroke();

                // Legs
                ctx.beginPath();
                ctx.moveTo(0, 10);
                ctx.lineTo(-5 + legSwing, 25); // Left Leg
                ctx.moveTo(0, 10);
                ctx.lineTo(5 - legSwing, 25); // Right Leg
                ctx.stroke();

                // Arms
                ctx.beginPath();
                let armY = -8;
                if (this.panic || !this.grounded) armY = -15; // Hands up falling
                
                ctx.moveTo(0, -8);
                ctx.lineTo(-10, armY + armSwing); // Left Arm
                ctx.moveTo(0, -8);
                ctx.lineTo(10, armY - armSwing); // Right Arm
                ctx.stroke();

                // Health bar if damaged
                if (this.hp < 100 && this.hp > 0) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(-10, -35, 20 * (this.hp/100), 3);
                }

                ctx.restore();
            }

            die() {
                super.die();
                // Spawn ragdoll parts
                // Head
                createDebris(this.x, this.y - 20, 8);
                // Body
                createDebris(this.x, this.y, 10);
            }
        }

        class Particle {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.03;
                this.color = color;
                this.size = size;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95;
                this.vy += GRAVITY * 0.5;
                this.life -= this.decay;
                
                // Floor bounce
                if (this.y > canvas.height) {
                    this.y = canvas.height;
                    this.vy *= -0.6;
                    this.vx *= 0.8;
                }
            }
            
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        class Projectile extends Entity {
            constructor(x, y, vx, vy) {
                super(x,y);
                this.vx = vx;
                this.vy = vy;
                this.radius = 3;
                this.color = '#000';
                this.life = 100;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // Minimal gravity
                
                // Check collisions
                entities.forEach(e => {
                    if (e === this || e.dead) return;
                    if (e instanceof Stickman) {
                        const dx = this.x - e.x;
                        const dy = this.y - e.y; // Center
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < e.radius + 10) {
                            e.takeDamage(35, this.x, this.y, 15);
                            this.dead = true;
                            createExplosion(this.x, this.y, 5, 'gray');
                        }
                    }
                });

                if (this.x < 0 || this.x > canvas.width || this.y > canvas.height) this.dead = true;
                this.life--;
                if(this.life <= 0) this.dead = true;
            }
        }

        class Bomb extends Entity {
            constructor(x, y) {
                super(x, y);
                this.radius = 8;
                this.color = '#000';
                this.timer = 60; // 1 second
                this.blink = false;
            }

            update() {
                super.update();
                this.vx *= 0.98; // Rolling friction
                this.timer--;
                
                if (this.timer % 10 === 0) this.blink = !this.blink;

                if (this.timer <= 0) {
                    this.explode();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.blink ? '#ff4444' : '#000';
                ctx.fill();
                
                // Fuse
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.quadraticCurveTo(5, -15, 8, -12);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Spark
                if (this.timer > 0) {
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(7, -13, 3, 3);
                }

                ctx.restore();
            }

            explode() {
                this.dead = true;
                createExplosion(this.x, this.y, 20, '#ef4444');
                
                // Camera shake
                document.body.classList.remove('shake');
                void document.body.offsetWidth; // trigger reflow
                document.body.classList.add('shake');

                // Blast radius
                entities.forEach(e => {
                    if (e === this || e.dead) return;
                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 150) {
                        const force = (150 - dist) * 0.4;
                        e.takeDamage(force * 2, this.x, this.y, force);
                    }
                });
            }
        }

        class Mine extends Entity {
            constructor(x, y) {
                super(x, y);
                this.radius = 6;
                this.active = false;
                setTimeout(() => this.active = true, 500); // Arming time
            }
            
            update() {
                super.update();
                if(!this.active) return;
                
                // Check contact
                 entities.forEach(e => {
                    if (e === this || e.dead || e instanceof Mine) return;
                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 20) {
                        this.explode();
                    }
                });
            }

             draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI, true); // Semi circle
                ctx.fillStyle = '#555';
                ctx.fill();
                
                if (this.active) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(-2, -8, 4, 4); // blinking light
                }

                ctx.restore();
            }

            explode() {
                this.dead = true;
                createExplosion(this.x, this.y, 15, '#fbbf24');
                 entities.forEach(e => {
                    if (e === this || e.dead) return;
                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 100) {
                        const force = (100 - dist) * 0.5;
                        e.takeDamage(force * 3, this.x, this.y, force * 1.5); // High upward force
                        e.vy -= 10;
                    }
                });
            }
        }

        class BlackHole extends Entity {
            constructor(x, y) {
                super(x, y);
                this.vx = 0;
                this.vy = 0;
                this.life = 300; // 5 seconds
                this.radius = 5;
            }

            update() {
                 this.life--;
                 if(this.life <= 0) this.dead = true;
                 
                 // Grow slightly
                 if (this.radius < 20) this.radius += 0.1;

                 // Suck
                 entities.forEach(e => {
                    if (e === this || e.dead) return;
                    const dx = this.x - e.x;
                    const dy = this.y - e.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 250) {
                        const force = 300 / (dist * dist + 1);
                        e.vx += dx * force * 0.1;
                        e.vy += dy * force * 0.1;
                        e.panic = true; // Make stickmen wave arms
                    }
                    
                    // Spaghettification (Kill zone)
                    if (dist < 20) {
                        e.takeDamage(100, this.x, this.y, 0);
                        e.dead = true; // Instant delete
                    }
                });
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + Math.random()*2, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
                ctx.strokeStyle = 'purple';
                ctx.stroke();
            }
        }


        // --- Helper Functions ---

        function createDebris(x, y, size) {
            let d = new Entity(x, y);
            d.radius = size;
            d.hp = 0; // Already dead object basically
            d.type = 'debris';
            d.color = '#1f2937';
            entities.push(d);
        }

        function createExplosion(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, 4 + Math.random() * 4));
            }
        }

        function spawnStickman(x, y) {
            let s = new Stickman(x, y);
            entities.push(s);
        }

        function selectTool(name) {
            currentTool = name;
            // Update UI
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active', 'bg-blue-600', 'text-white'));
            const btn = document.getElementById('tool-' + name);
            if(btn) btn.classList.add('active');
        }

        function clearAll() {
            entities = [];
            particles = [];
            grabbedEntity = null;
        }
        
        function resetCamera() {
            // Placeholder if we add camera pan later
        }

        // --- Interaction ---

        function handleInputStart(x, y) {
            isMouseDown = true;
            mouseX = x;
            mouseY = y;
            lastMouseX = x;
            lastMouseY = y;

            if (currentTool === 'spawn') {
                spawnStickman(x, y);
            }
            else if (currentTool === 'bomb') {
                entities.push(new Bomb(x, y));
            }
            else if (currentTool === 'mine') {
                entities.push(new Mine(x, y));
            }
            else if (currentTool === 'blackhole') {
                 entities.push(new BlackHole(x, y));
            }
            else if (currentTool === 'gun') {
                // Shoot multiple times if held? For now just once per click
                // But let's check inputLoop for auto fire maybe?
                // Just shoot once for now
                let bullet = new Projectile(x, y, 0, 0);
                // Shoot towards center of screen or just straight down? 
                // Let's shoot slightly randomly downwards to feel like "dropping" shots or user aimed
                // Actually, let's shoot towards the ground
                bullet.vy = 20; 
                bullet.vx = (Math.random()-0.5) * 5;
                entities.push(bullet);
            }
            else if (currentTool === 'smash') {
                // AoE Damage at click
                createExplosion(x, y, 5, 'white');
                entities.forEach(e => {
                    const dist = Math.sqrt(Math.pow(e.x - x, 2) + Math.pow(e.y - y, 2));
                    if (dist < 50) {
                        e.takeDamage(50, x, y, 30); // High force
                        e.vy = 10; // Slam down
                    }
                });
            }
            else if (currentTool === 'hand') {
                // Find closest entity
                let closest = null;
                let minDist = 50;
                
                entities.forEach(e => {
                    const dist = Math.sqrt(Math.pow(e.x - x, 2) + Math.pow(e.y - y, 2));
                    if (dist < minDist) {
                        closest = e;
                        minDist = dist;
                    }
                });

                if (closest) {
                    grabbedEntity = closest;
                    grabbedEntity.panic = true;
                }
            }
        }

        function handleInputMove(x, y) {
            mouseX = x;
            mouseY = y;
            
            // Calculate mouse velocity for throwing
            mouseVx = x - lastMouseX;
            mouseVy = y - lastMouseY;
            lastMouseX = x;
            lastMouseY = y;

            if (isMouseDown) {
                 if (currentTool === 'hand' && grabbedEntity) {
                    grabbedEntity.x = x;
                    grabbedEntity.y = y;
                    grabbedEntity.vx = 0;
                    grabbedEntity.vy = 0;
                }
                else if (currentTool === 'gun' && Math.random() > 0.8) {
                     // Machine gun effect while dragging
                    let bullet = new Projectile(x + (Math.random()-0.5)*20, y + (Math.random()-0.5)*20, 0, 25);
                    bullet.vx = (Math.random()-0.5)*2;
                    entities.push(bullet);
                }
            }
        }

        function handleInputEnd() {
            isMouseDown = false;
            if (grabbedEntity) {
                // Throw
                grabbedEntity.vx = mouseVx;
                grabbedEntity.vy = mouseVy;
                grabbedEntity.panic = false;
                grabbedEntity = null;
            }
        }

        // Event Listeners
        canvas.addEventListener('mousedown', e => handleInputStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', handleInputEnd);
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            handleInputStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); // Stop scrolling
            handleInputMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        canvas.addEventListener('touchend', handleInputEnd);


        // --- Initial State ---
        // Spawn a few guys
        for(let i=0; i<5; i++) {
            spawnStickman(canvas.width/2 + (Math.random()-0.5)*200, canvas.height - 50);
        }

        // --- Main Loop ---

        function loop() {
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update Entities
            // Filter out dead ones efficiently
            for (let i = entities.length - 1; i >= 0; i--) {
                let e = entities[i];
                if (e !== grabbedEntity) e.update();
                
                if (e.dead && e.type !== 'debris' && e.type !== 'stickman') {
                     // Non-stickmen (bombs etc) disappear when dead
                     entities.splice(i, 1);
                     continue;
                }
                
                // Cleanup fallen stickmen or debris eventually
                if (e.dead && Math.random() > 0.99) {
                     e.life = (e.life || 100) - 1;
                     if(e.life <= 0) entities.splice(i, 1);
                }
                
                // Cleanup falling off world (bug safety)
                if (e.y > canvas.height + 100) entities.splice(i, 1);
            }

            // Draw Entities
            entities.forEach(e => e.draw());

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(i, 1);
            }

            // UI Updates
            entityCountDisplay.innerText = entities.filter(e => e.type === 'stickman' && !e.dead).length;

            requestAnimationFrame(loop);
        }

        loop();

    </script>
</body>
</html>

