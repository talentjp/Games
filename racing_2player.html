<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multiplayer Kart Racer</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a202c; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-layer { position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }
        
        /* Mobile Controls */
        .joystick-area { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1); border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); touch-action: none; }
        .joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%); }
        .action-btn { position: absolute; bottom: 40px; right: 40px; width: 80px; height: 80px; background: rgba(239, 68, 68, 0.8); border-radius: 50%; border: 4px solid rgba(255,255,255,0.4); display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; user-select: none; touch-action: manipulation; }
        .action-btn:active { background: rgba(239, 68, 68, 1); transform: scale(0.95); }

        /* Scanning UI */
        #reader { width: 100%; max-width: 400px; margin: 0 auto; background: black; }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="game-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer" class="ui-layer flex flex-col justify-center align-center">
        
        <!-- Main Menu -->
        <div id="menu-screen" class="interactive absolute inset-0 flex flex-col items-center justify-center bg-gray-900 bg-opacity-95 text-white transition-opacity duration-300">
            <h1 class="text-5xl font-extrabold mb-8 italic text-yellow-400 tracking-wider drop-shadow-lg">TURBO DRIFT</h1>
            
            <div class="flex flex-col gap-4 w-64">
                <button onclick="startGame('host')" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition hover:scale-105">
                    HOST GAME
                </button>
                <button onclick="showJoinScreen()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition hover:scale-105">
                    JOIN GAME
                </button>
            </div>
            
            <p class="mt-8 text-gray-400 text-sm">Use Arrow Keys or WASD to Drive</p>
        </div>

        <!-- Host Screen -->
        <div id="host-screen" class="hidden interactive absolute inset-0 flex flex-col items-center justify-center bg-gray-900 bg-opacity-95 text-white">
            <h2 class="text-2xl font-bold mb-4">Waiting for Player 2...</h2>
            <div id="qrcode" class="bg-white p-4 rounded-lg mb-4"></div>
            <p class="text-gray-300 mb-2">Scan with another device to join</p>
            <p class="text-sm text-gray-500">Room ID: <span id="host-id-display" class="font-mono text-yellow-300 select-all">Loading...</span></p>
            <button onclick="resetToMenu()" class="mt-6 text-gray-400 underline hover:text-white">Cancel</button>
        </div>

        <!-- Join Screen -->
        <div id="join-screen" class="hidden interactive absolute inset-0 flex flex-col items-center justify-center bg-gray-900 bg-opacity-95 text-white">
            <h2 class="text-2xl font-bold mb-4">Join Game</h2>
            
            <div id="reader" class="rounded-lg overflow-hidden border-2 border-gray-600 mb-4 h-64 w-64 bg-black"></div>
            
            <div class="flex flex-col gap-2 w-64">
                <input type="text" id="remote-id-input" placeholder="Or enter Room ID manually" class="text-black px-4 py-2 rounded font-mono text-center">
                <button onclick="joinGameManually()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded shadow">
                    Connect
                </button>
            </div>
            <button onclick="resetToMenu()" class="mt-4 text-gray-400 underline hover:text-white">Back</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden absolute inset-0 pointer-events-none">
            <div class="absolute top-4 left-4 text-white font-bold text-xl drop-shadow-md">
                <span id="player-role" class="text-yellow-400">PLAYER</span>
            </div>
            <div class="absolute top-4 right-4 text-white font-bold text-xl drop-shadow-md">
                <span id="connection-status" class="text-red-500">OFFLINE</span>
            </div>
            
            <!-- Mobile Controls (Visible only on touch devices usually, simplified here to always show or based on detection) -->
            <div id="mobile-controls" class="hidden interactive">
                <div id="joystick" class="joystick-area">
                    <div id="joystick-knob" class="joystick-knob"></div>
                </div>
                <div id="btn-drift" class="action-btn">DRIFT</div>
            </div>
        </div>
    </div>

<script>
/**
 * CONFIGURATION & GLOBALS
 */
// Config from user's request (The specific file)
// Standard reliable STUN server. If you have the specific TURN credentials, add them here.
const PEER_CONFIG = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' } 
        // Add TURN servers here if needed
    ]
};

let scene, camera, renderer;
let myKart, remoteKart;
let trackMesh;
let lastTime = 0;
let isHost = false;
let peer, conn;
let gameActive = false;
let myId = null;

// Game State
const state = {
    my: { x: 0, y: 0, z: 0, rot: 0, speed: 0, steering: 0 },
    remote: { x: 0, y: 0, z: 0, rot: 0 },
    inputs: { up: false, down: false, left: false, right: false, drift: false }
};

// Physics Constants
const MAX_SPEED = 0.8;
const ACCEL = 0.02;
const DECEL = 0.96; // Friction
const TURN_SPEED = 0.06;

/**
 * INIT & ENTRY POINT
 */
window.onload = () => {
    initThree();
    setupInputs();
    setupMobileControls();
    animate();
    
    // Check if mobile for UI
    if(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)){
        document.getElementById('mobile-controls').classList.remove('hidden');
    }
};

function resetToMenu() {
    document.getElementById('menu-screen').classList.remove('hidden');
    document.getElementById('host-screen').classList.add('hidden');
    document.getElementById('join-screen').classList.add('hidden');
    document.getElementById('hud').classList.add('hidden');
    
    if (html5QrCode) {
        try { html5QrCode.stop(); } catch(e) {}
    }
}

function showJoinScreen() {
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('join-screen').classList.remove('hidden');
    startQRScanner();
}

/**
 * THREE.JS SETUP
 */
function initThree() {
    const container = document.getElementById('game-container');
    
    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue
    scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

    // Camera
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, -10);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // Track (Procedural)
    createTrack();

    // Karts
    myKart = createKart(0x3B82F6); // Blue
    remoteKart = createKart(0xEF4444); // Red
    
    // Initial Positions
    myKart.position.set(5, 0.5, 0);
    remoteKart.position.set(-5, 0.5, 0);
    
    scene.add(myKart);
    scene.add(remoteKart);
    
    // Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function createKart(colorHex) {
    const kartGroup = new THREE.Group();
    
    // Body
    const bodyGeo = new THREE.BoxGeometry(1, 0.5, 2);
    const bodyMat = new THREE.MeshLambertMaterial({ color: colorHex });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.5;
    body.castShadow = true;
    kartGroup.add(body);
    
    // Spoiler
    const spoilerGeo = new THREE.BoxGeometry(1.2, 0.1, 0.5);
    const spoiler = new THREE.Mesh(spoilerGeo, new THREE.MeshLambertMaterial({ color: 0x333333 }));
    spoiler.position.set(0, 1, -0.8);
    kartGroup.add(spoiler);

    const postGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
    const post1 = new THREE.Mesh(postGeo, new THREE.MeshLambertMaterial({color:0x111111}));
    post1.position.set(0.3, 0.75, -0.8);
    const post2 = post1.clone();
    post2.position.set(-0.3, 0.75, -0.8);
    kartGroup.add(post1);
    kartGroup.add(post2);

    // Wheels
    const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
    const wheelMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
    
    const wheels = [
        { x: 0.6, z: 0.6 },
        { x: -0.6, z: 0.6 },
        { x: 0.6, z: -0.6 },
        { x: -0.6, z: -0.6 }
    ];
    
    wheels.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(pos.x, 0.3, pos.z);
        wheel.castShadow = true;
        kartGroup.add(wheel);
    });
    
    // Driver Head
    const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.set(0, 1.0, 0.2);
    kartGroup.add(head);

    return kartGroup;
}

function createTrack() {
    // Ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x228B22, 
        roughness: 1 
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Track Surface (Simple Loop)
    const trackWidth = 8;
    const trackRadius = 40;
    
    const trackGeo = new THREE.RingGeometry(trackRadius - trackWidth/2, trackRadius + trackWidth/2, 64);
    const trackMat = new THREE.MeshStandardMaterial({ 
        color: 0x555555,
        roughness: 0.8 
    });
    trackMesh = new THREE.Mesh(trackGeo, trackMat);
    trackMesh.rotation.x = -Math.PI / 2;
    trackMesh.receiveShadow = true;
    scene.add(trackMesh);
    
    // Start Line
    const startLineGeo = new THREE.PlaneGeometry(trackWidth, 2);
    const startLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Checkerboard simplified
    const startLine = new THREE.Mesh(startLineGeo, startLineMat);
    startLine.rotation.x = -Math.PI / 2;
    startLine.position.set(trackRadius, 0.02, 0);
    scene.add(startLine);
}

/**
 * GAME LOGIC
 */
function animate() {
    requestAnimationFrame(animate);
    
    if (gameActive) {
        updatePhysics();
        updateNetwork();
        updateCamera();
    }
    
    renderer.render(scene, camera);
}

function updatePhysics() {
    // 1. Acceleration
    if (state.inputs.up) {
        state.my.speed += ACCEL;
    } else if (state.inputs.down) {
        state.my.speed -= ACCEL;
    }
    
    // 2. Friction
    state.my.speed *= DECEL;
    
    // 3. Cap speed
    if (state.my.speed > MAX_SPEED) state.my.speed = MAX_SPEED;
    if (state.my.speed < -MAX_SPEED/2) state.my.speed = -MAX_SPEED/2;
    
    // 4. Steering (only if moving)
    if (Math.abs(state.my.speed) > 0.01) {
        const dir = state.my.speed > 0 ? 1 : -1;
        if (state.inputs.left) {
            state.my.rot += TURN_SPEED * dir;
        }
        if (state.inputs.right) {
            state.my.rot -= TURN_SPEED * dir;
        }
    }
    
    // 5. Update Position
    state.my.x += Math.sin(state.my.rot) * state.my.speed;
    state.my.z += Math.cos(state.my.rot) * state.my.speed;
    
    // 6. Apply to Mesh
    myKart.position.x = state.my.x;
    myKart.position.z = state.my.z;
    myKart.rotation.y = state.my.rot;
    
    // 7. Update Remote Kart (Interpolation could be added here for smoothness)
    remoteKart.position.x = state.remote.x;
    remoteKart.position.z = state.remote.z;
    remoteKart.rotation.y = state.remote.rot;
}

function updateCamera() {
    // Smooth follow
    const relativeOffset = new THREE.Vector3(0, 5, -10);
    const cameraOffset = relativeOffset.applyMatrix4(myKart.matrixWorld);
    
    camera.position.lerp(cameraOffset, 0.1);
    camera.lookAt(myKart.position.x, myKart.position.y + 1, myKart.position.z);
}

/**
 * NETWORKING (PeerJS)
 */
function startGame(mode) {
    document.getElementById('menu-screen').classList.add('hidden');
    
    peer = new Peer(null, PEER_CONFIG);
    
    peer.on('open', (id) => {
        myId = id;
        console.log('My Peer ID:', id);
        
        if (mode === 'host') {
            isHost = true;
            document.getElementById('host-screen').classList.remove('hidden');
            document.getElementById('host-id-display').innerText = id;
            
            // Generate QR Code
            document.getElementById('qrcode').innerHTML = "";
            new QRCode(document.getElementById("qrcode"), {
                text: id,
                width: 128,
                height: 128
            });
            
            // Wait for connection
            peer.on('connection', (c) => {
                conn = c;
                setupConnection();
            });
        }
    });
    
    peer.on('error', (err) => {
        alert("Network Error: " + err.type);
        console.error(err);
    });
}

function joinGameManually() {
    const remoteId = document.getElementById('remote-id-input').value.trim();
    if (!remoteId) return alert("Please enter a Room ID");
    connectToHost(remoteId);
}

function connectToHost(hostId) {
    if (!peer) return; // Should be initialized
    
    conn = peer.connect(hostId);
    setupConnection();
}

function setupConnection() {
    if (!conn) return;
    
    conn.on('open', () => {
        console.log("Connected to peer!");
        
        // Hide Menus, Show HUD
        document.getElementById('host-screen').classList.add('hidden');
        document.getElementById('join-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        
        // Set Role Display
        document.getElementById('player-role').innerText = isHost ? "HOST (Player 1)" : "GUEST (Player 2)";
        document.getElementById('connection-status').innerText = "CONNECTED";
        document.getElementById('connection-status').classList.replace("text-red-500", "text-green-500");
        
        // Stop QR Scanner if running
        if (html5QrCode) {
            try { html5QrCode.stop(); } catch(e) {}
        }
        
        // Reset Positions
        if (isHost) {
            state.my.x = 42; state.my.z = 0; // Host Start
            state.my.rot = Math.PI; // Face forward along track
            myKart.position.set(42, 0.5, 0);
        } else {
            state.my.x = 38; state.my.z = 0; // Client Start
            state.my.rot = Math.PI;
            myKart.position.set(38, 0.5, 0);
        }

        gameActive = true;
    });
    
    conn.on('data', (data) => {
        // Receive Remote State
        if (data.type === 'state') {
            state.remote.x = data.x;
            state.remote.z = data.z;
            state.remote.rot = data.rot;
        }
    });
    
    conn.on('close', () => {
        alert("Peer disconnected");
        location.reload();
    });
}

function updateNetwork() {
    if (conn && conn.open && gameActive) {
        // Send my state
        conn.send({
            type: 'state',
            x: state.my.x,
            z: state.my.z,
            rot: state.my.rot
        });
    }
}

/**
 * QR CODE SCANNER
 */
let html5QrCode;

function startQRScanner() {
    html5QrCode = new Html5Qrcode("reader");
    const config = { fps: 10, qrbox: { width: 200, height: 200 } };
    
    html5QrCode.start({ facingMode: "environment" }, config, (decodedText, decodedResult) => {
        // Success
        console.log(`Code matched = ${decodedText}`);
        html5QrCode.stop().then(() => {
            // Initialize Peer if not done (for Joiner)
            if(!peer) {
                peer = new Peer(null, PEER_CONFIG);
                peer.on('open', (id) => {
                    myId = id;
                    connectToHost(decodedText);
                });
            } else {
                connectToHost(decodedText);
            }
        });
    }, (errorMessage) => {
        // parse error, ignore
    }).catch(err => {
        console.error("Camera permission or start failed", err);
        document.getElementById('reader').innerText = "Camera not available. Use Manual ID.";
    });
}

/**
 * INPUT HANDLING
 */
function setupInputs() {
    // Keyboard
    document.addEventListener('keydown', (e) => {
        switch(e.key) {
            case 'ArrowUp': case 'w': state.inputs.up = true; break;
            case 'ArrowDown': case 's': state.inputs.down = true; break;
            case 'ArrowLeft': case 'a': state.inputs.left = true; break;
            case 'ArrowRight': case 'd': state.inputs.right = true; break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        switch(e.key) {
            case 'ArrowUp': case 'w': state.inputs.up = false; break;
            case 'ArrowDown': case 's': state.inputs.down = false; break;
            case 'ArrowLeft': case 'a': state.inputs.left = false; break;
            case 'ArrowRight': case 'd': state.inputs.right = false; break;
        }
    });
}

function setupMobileControls() {
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('joystick-knob');
    let startX, startY;
    
    joystick.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        state.inputs.up = true; // Gas on touch
    });
    
    joystick.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;
        
        // Clamp visuals
        const dist = Math.min(40, Math.sqrt(deltaX*deltaX + deltaY*deltaY));
        const angle = Math.atan2(deltaY, deltaX);
        const kx = Math.cos(angle) * dist;
        const ky = Math.sin(angle) * dist;
        
        knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
        
        // Logic
        if (deltaX < -10) { state.inputs.left = true; state.inputs.right = false; }
        else if (deltaX > 10) { state.inputs.right = true; state.inputs.left = false; }
        else { state.inputs.left = false; state.inputs.right = false; }
    });
    
    joystick.addEventListener('touchend', (e) => {
        e.preventDefault();
        knob.style.transform = `translate(-50%, -50%)`;
        state.inputs.up = false;
        state.inputs.left = false;
        state.inputs.right = false;
    });
    
    const driftBtn = document.getElementById('btn-drift');
    driftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); state.inputs.down = true; }); // Brake/Drift
    driftBtn.addEventListener('touchend', (e) => { e.preventDefault(); state.inputs.down = false; });
}

</script>
</body>
</html>
