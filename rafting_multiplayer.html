<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>River Rush Co-op</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .hud-top { padding: 20px; display: flex; justify-content: space-between; color: white; text-shadow: 2px 2px 0 #000; font-size: 24px; font-weight: bold; }
        
        .controls { 
            pointer-events: auto; 
            display: flex; 
            justify-content: space-between; 
            padding: 20px 40px;
            padding-bottom: 40px;
        }

        .btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            user-select: none;
            cursor: pointer;
            transition: transform 0.1s, background 0.1s;
        }
        .btn:active { transform: scale(0.95); background: rgba(255, 255, 255, 0.5); }
        
        #status-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 40px;
            font-weight: 900;
            text-shadow: 3px 3px 0 #000;
            text-align: center;
            display: none;
            pointer-events: auto;
            cursor: pointer;
        }

        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Playroom Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/playroomkit/multiplayer.umd.js"></script>
</head>
<body>

    <div id="loading">Connecting...</div>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score">Dist: 0m</div>
            <div id="players">Paddlers: 1</div>
        </div>
        <div id="status-msg">
            <div id="status-text">READY?</div>
            <div id="restart-hint" style="font-size: 16px; margin-top:10px;"></div>
        </div>
        <div class="controls">
            <div class="btn" id="btn-left">◀</div>
            <div class="btn" id="btn-right">▶</div>
        </div>
        <div id="debug-info">Init...</div>
    </div>

    <script>
        // --- Configuration ---
        const RIVER_WIDTH = 40;
        const RIVER_LENGTH = 2000;
        const RAFT_SPEED = 0.5;
        const STEER_FORCE = 0.6;

        // --- Globals ---
        let scene, camera, renderer;
        let raft, water;
        let obstacles = []; // 3D Mesh Array
        let isOnline = false;
        let isHost = false;
        let offlineMode = false;
        let myPlayerId = null;

        // --- Game State ---
        // 'localState' is what we render. 
        // If Host, we modify this and broadcast it.
        // If Client, we overwrite this with data from the network.
        let localState = {
            raftX: 0,
            distance: 0,
            obstacles: [], // Data objects {id, x, z, type}
            status: 'playing',
            lastSyncTime: 0
        };

        let localInput = 0; // -1, 0, 1

        // --- Entry Point ---
        window.onload = function() {
            // 1. Setup Graphics immediately (so screen isn't blue)
            setupThreeJS();
            setupControls();
            
            // 2. Start Animation Loop immediately
            requestAnimationFrame(animate);

            // 3. Attempt Connection
            connectToPlayroom();
        };

        async function connectToPlayroom() {
            updateDebug("Connecting...");
            try {
                // Timeout protection
                const timeout = new Promise((_, reject) => setTimeout(() => reject("Timeout"), 4000));
                
                await Promise.race([
                    Playroom.insertCoin({ skipLobby: false, gameId: "river-rush-v3", discord: false }),
                    timeout
                ]);

                isOnline = true;
                isHost = Playroom.isHost();
                myPlayerId = Playroom.myPlayer()?.id;
                
                updateDebug(isHost ? "Host Connected" : "Client Connected");
                
                // If Host, ensure we broadcast the initial clean state immediately
                if (isHost) {
                    await Playroom.setState('gameState', localState);
                }

                document.getElementById('loading').style.display = 'none';

            } catch (e) {
                console.warn("Offline Mode:", e);
                startOfflineMode();
            }
        }

        function startOfflineMode() {
            offlineMode = true;
            isHost = true; // Play as host locally
            updateDebug("Offline Mode");
            document.getElementById('loading').style.display = 'none';
        }

        // --- Graphics Setup ---
        function setupThreeJS() {
            if (scene) return;

            const container = document.getElementById('game-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 15, -18);
            camera.lookAt(0, 0, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, -50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Environment
            createEnvironment();
            
            // Raft
            raft = createRaft();
            scene.add(raft);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createEnvironment() {
            // Water
            const waterGeo = new THREE.PlaneGeometry(RIVER_WIDTH * 3, 200, 40, 40);
            waterGeo.rotateX(-Math.PI / 2);
            const waterMat = new THREE.MeshPhongMaterial({ 
                color: 0x0099ff, shininess: 60, flatShading: true, transparent: true, opacity: 0.9 
            });
            water = new THREE.Mesh(waterGeo, waterMat);
            scene.add(water);

            // Banks
            const bankGeo = new THREE.BoxGeometry(20, 10, 200);
            const bankMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const left = new THREE.Mesh(bankGeo, bankMat);
            left.position.set(-(RIVER_WIDTH/2 + 10), -2, 0);
            scene.add(left);
            const right = new THREE.Mesh(bankGeo, bankMat);
            right.position.set((RIVER_WIDTH/2 + 10), -2, 0);
            scene.add(right);
        }

        function createRaft() {
            const group = new THREE.Group();
            const logGeo = new THREE.CylinderGeometry(0.6, 0.6, 6, 8);
            const logMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            
            for(let i=0; i<5; i++) {
                const log = new THREE.Mesh(logGeo, logMat);
                log.rotation.set(Math.PI/2, 0, Math.PI/2);
                log.position.x = (i - 2) * 1.2;
                log.castShadow = true;
                group.add(log);
            }
            
            // Sail
            const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), logMat);
            mast.position.y = 2;
            group.add(mast);
            
            const sail = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 1.5), 
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
            );
            sail.position.set(1, 3.5, 0);
            group.add(sail);
            
            return group;
        }

        function createObstacleMesh(data) {
            let mesh;
            if (data.type === 'rock') {
                mesh = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1.5), 
                    new THREE.MeshLambertMaterial({ color: 0x808080 })
                );
                mesh.position.y = 0.5;
            } else {
                mesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 4), 
                    new THREE.MeshLambertMaterial({ color: 0x5c4033 })
                );
                mesh.rotation.z = Math.PI / 2;
                mesh.rotation.y = Math.random();
            }
            mesh.castShadow = true;
            return mesh;
        }

        // --- Controls ---
        function setupControls() {
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const statusBox = document.getElementById('status-msg');

            const setInput = (val) => {
                localInput = val;
                if (isOnline && Playroom.myPlayer()) {
                    Playroom.myPlayer().setState('dir', val);
                }
            };

            // Restart Handler
            statusBox.onclick = () => {
                if ((isHost || offlineMode) && (localState.status === 'gameover' || localState.status === 'won')) {
                    resetGame();
                }
            };

            // UI Events
            const bindBtn = (btn, val) => {
                btn.onpointerdown = (e) => { e.preventDefault(); setInput(val); btn.style.background = 'rgba(255,255,255,0.6)'; };
                btn.onpointerup = (e) => { e.preventDefault(); setInput(0); btn.style.background = ''; };
                btn.onpointerleave = (e) => { e.preventDefault(); setInput(0); btn.style.background = ''; };
            };
            bindBtn(btnLeft, -1);
            bindBtn(btnRight, 1);

            window.onkeydown = (e) => {
                if(e.key === 'ArrowLeft') { setInput(-1); btnLeft.style.background = 'rgba(255,255,255,0.6)'; }
                if(e.key === 'ArrowRight') { setInput(1); btnRight.style.background = 'rgba(255,255,255,0.6)'; }
            };
            window.onkeyup = (e) => {
                if(e.key === 'ArrowLeft' || e.key === 'ArrowRight') { setInput(0); btnLeft.style.background = ''; btnRight.style.background = ''; }
            };
        }

        function resetGame() {
            localState.raftX = 0;
            localState.distance = 0;
            localState.status = 'playing';
            localState.obstacles = [];
            if(isOnline) Playroom.setState('gameState', localState);
            
            // Clear meshes
            obstacles.forEach(m => scene.remove(m));
            obstacles = [];
        }

        // --- Core Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // --- 1. Networking / Input Gathering ---
            let players = [];
            let totalSteer = 0;

            if (isOnline) {
                try {
                    players = Playroom.getPlayers();
                    players.forEach(p => {
                         // Safety check for player state
                         let dir = p.getState ? p.getState('dir') : 0;
                         totalSteer += (Number.isFinite(dir) ? dir : 0);
                    });
                } catch(e) { /* Ignore net errors */ }
            } else {
                players = [{id: 'me'}];
                totalSteer = localInput;
            }

            // Update Player Count UI
            const pCount = players.length > 0 ? players.length : 1;
            document.getElementById('players').innerText = "Paddlers: " + pCount;

            // --- 2. Game Logic (Host Authority) ---
            if (isHost || offlineMode) {
                if (localState.status === 'playing') {
                    // Move
                    localState.distance += RAFT_SPEED;

                    // Steer (Average force)
                    const steerFactor = totalSteer / pCount;
                    localState.raftX -= steerFactor * STEER_FORCE;

                    // Clamp (Prevent going off world)
                    localState.raftX = Math.max(-(RIVER_WIDTH/2 - 2), Math.min((RIVER_WIDTH/2 - 2), localState.raftX));

                    // Spawn Obstacles (Only after 200m)
                    if (localState.distance > 200 && Math.random() < 0.02) {
                        localState.obstacles.push({
                            id: Date.now() + Math.random(),
                            type: Math.random() > 0.5 ? 'rock' : 'log',
                            x: (Math.random() * (RIVER_WIDTH - 6)) - (RIVER_WIDTH/2 - 3),
                            z: 80 // Spawn ahead
                        });
                    }

                    // Move Obstacles (towards raft)
                    localState.obstacles.forEach(o => o.z -= RAFT_SPEED);
                    
                    // Cleanup old obstacles
                    localState.obstacles = localState.obstacles.filter(o => o.z > -20);

                    // Collision Check
                    for (let obs of localState.obstacles) {
                        const dx = obs.x - localState.raftX;
                        const dz = obs.z - 0; // Raft is at 0
                        if (Math.sqrt(dx*dx + dz*dz) < 3.0) {
                            localState.status = 'gameover';
                            break;
                        }
                    }

                    // Win Check
                    if (localState.distance >= RIVER_LENGTH) localState.status = 'won';

                    // Broadcast
                    if (isOnline) {
                        Playroom.setState('gameState', localState);
                    }
                }
            } 
            // --- 3. Client Synchronization ---
            else if (isOnline && !isHost) {
                const serverState = Playroom.getState('gameState');
                if (serverState && typeof serverState.raftX === 'number') {
                    // Valid state received
                    localState.raftX = THREE.MathUtils.lerp(localState.raftX, serverState.raftX, 0.2);
                    localState.distance = serverState.distance;
                    localState.status = serverState.status;
                    localState.obstacles = serverState.obstacles || [];
                    updateDebug("Client: Synced");
                } else {
                    updateDebug("Waiting for Host...");
                }
            }

            // --- 4. Rendering ---
            renderScene(totalSteer);
        }

        function renderScene(steerInput) {
            if (!raft || !scene || !camera) return;

            // Update Raft Visuals
            if (Number.isFinite(localState.raftX)) {
                raft.position.x = localState.raftX;
            }
            raft.rotation.z = THREE.MathUtils.lerp(raft.rotation.z, steerInput * -0.05, 0.1);
            raft.position.y = Math.sin(Date.now() * 0.003) * 0.2;

            // Sync Obstacle Meshes
            // 1. Mark all existing as 'unseen'
            obstacles.forEach(m => m.userData.seen = false);

            // 2. Update or Create meshes based on state
            if (localState.obstacles) {
                localState.obstacles.forEach(data => {
                    let mesh = obstacles.find(m => m.userData.id === data.id);
                    if (!mesh) {
                        mesh = createObstacleMesh(data);
                        mesh.userData.id = data.id;
                        mesh.position.x = data.x; // X never changes after spawn
                        scene.add(mesh);
                        obstacles.push(mesh);
                    }
                    mesh.position.z = data.z;
                    mesh.userData.seen = true;
                });
            }

            // 3. Remove unseen meshes
            for (let i = obstacles.length - 1; i >= 0; i--) {
                if (!obstacles[i].userData.seen) {
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                }
            }

            // Update UI
            document.getElementById('score').innerText = `Dist: ${Math.floor(localState.distance)}m / ${RIVER_LENGTH}m`;
            
            const statusEl = document.getElementById('status-msg');
            const statusText = document.getElementById('status-text');
            const hint = document.getElementById('restart-hint');

            if (localState.status === 'gameover') {
                statusEl.style.display = 'block';
                statusText.innerText = "CRASHED!";
                statusText.style.color = '#ff4444';
                hint.innerText = (isHost || offlineMode) ? "(Tap to Restart)" : "Waiting for Host...";
            } else if (localState.status === 'won') {
                statusEl.style.display = 'block';
                statusText.innerText = "VICTORY!";
                statusText.style.color = '#4eff4e';
                hint.innerText = (isHost || offlineMode) ? "(Tap to Play Again)" : "";
            } else {
                statusEl.style.display = 'none';
            }

            // Animate Water
            if(water) {
                const pos = water.geometry.attributes.position;
                const time = Date.now() * 0.002;
                for(let i=0; i<pos.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i); // This is Z in world space (rotated plane)
                    // Move wave pattern backwards to simulate forward movement
                    const flow = y - (time * 5); 
                    const z = Math.sin(x*0.3 + time)*0.3 + Math.sin(flow*0.2)*0.5;
                    pos.setZ(i, z);
                }
                pos.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        function updateDebug(msg) {
            document.getElementById('debug-info').innerText = msg;
        }

    </script>
</body>
</html>

