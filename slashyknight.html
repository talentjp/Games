<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxel Quest: Speed Run</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* --- Base Settings --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #4fc3f7;
            font-family: 'Fredoka One', cursive;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* --- Touch Zones (Layer 1) --- */
        .tap-zone {
            position: absolute;
            top: 0;
            height: 100%;
            width: 50%;
            z-index: 10;
            display: none; 
        }
        #left-zone { left: 0; }
        #right-zone { right: 0; }

        /* --- HUD (Layer 2) --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        .hud-panel {
            background: #5d4037;
            border: 3px solid #3e2723;
            border-radius: 12px;
            padding: 10px 20px;
            color: white;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
            font-size: 1.5rem;
        }

        #controls-hint {
            text-align: center;
            color: rgba(255,255,255,0.9);
            font-size: 1.2rem;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.2);
            margin-bottom: 40px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* --- Menu Overlay (Layer 3) --- */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 136, 229, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            color: white;
            font-size: 3.5rem;
            margin: 0 0 10px 0;
            text-shadow: 0 6px 0 #0d47a1;
            text-align: center;
        }

        p {
            color: #e3f2fd;
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
        }

        #start-btn {
            background: #7cb342;
            color: white;
            border: none;
            padding: 20px 80px;
            font-size: 2rem;
            border-radius: 50px;
            font-family: 'Fredoka One', cursive;
            box-shadow: 0 8px 0 #558b2f;
            cursor: pointer;
            pointer-events: auto;
            touch-action: manipulation;
            transition: transform 0.1s;
        }

        #start-btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #558b2f;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    
    <div id="left-zone" class="tap-zone"></div>
    <div id="right-zone" class="tap-zone"></div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="hud-panel">
                <span>üõ°Ô∏è</span>&nbsp;<span id="score">0</span>
            </div>
            <div class="hud-panel" style="background:#ffb300; border-color:#ff6f00;">
                <span id="highscore">HI: 0</span>
            </div>
        </div>
        
        <div id="controls-hint" id="hint-text">
            Tap to Start Moving
        </div>
    </div>

    <div id="overlay">
        <h1 id="title-text">VOXEL QUEST</h1>
        <p id="desc-text">Tap Left/Right to change direction.<br>Speed increases over time!</p>
        <button id="start-btn" onclick="window.startGame()">PLAY</button>
    </div>

    <script>
        // --- Game Constants ---
        const CONFIG = {
            tileSize: 10,
            camZoom: 45,
            renderDist: 18,
            // Speed Settings (Duration in ms, lower is faster)
            startSpeed: 500, 
            minSpeed: 200,    
            acceleration: 0.5, // ms reduced per step
            
            colors: {
                sky: 0x4fc3f7,
                water: 0x29b6f6,
                grass: 0x81c784,
                dirt: 0x5d4037,
                hero: 0xffffff,
                enemy: 0xe53935,
                wood: 0x8d6e63
            }
        };

        // --- Global State ---
        let scene, camera, renderer;
        let knight, swordGroup;
        let gameState = 'MENU';
        let score = 0;
        let highScore = 0;
        let playerPos = { x: 0, z: 0 };
        
        // MOVEMENT STATE
        let isMoving = false;
        let currentDirection = null;
        let currentMoveDuration = CONFIG.startSpeed;

        // Data Storage
        const map = new Map();
        const tweens = [];

        // --- Initialization ---
        function init() {
            const container = document.getElementById('game-container');
            
            // 1. Three.js Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);

            const aspect = window.innerWidth / window.innerHeight;
            const d = CONFIG.camZoom;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 2000);
            camera.position.set(200, 200, 200); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 2. Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(-50, 150, -50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            const shadowD = 150;
            sun.shadow.camera.left = -shadowD;
            sun.shadow.camera.right = shadowD;
            sun.shadow.camera.top = shadowD;
            sun.shadow.camera.bottom = -shadowD;
            scene.add(sun);

            // 3. World Base
            createHero();
            const seaGeo = new THREE.PlaneGeometry(3000, 3000);
            const seaMat = new THREE.MeshToonMaterial({ color: CONFIG.colors.water });
            const sea = new THREE.Mesh(seaGeo, seaMat);
            sea.rotation.x = -Math.PI / 2;
            sea.position.y = -20;
            scene.add(sea);

            // 4. Listeners
            document.getElementById('left-zone').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                setInput('LEFT');
            });
            document.getElementById('right-zone').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                setInput('RIGHT');
            });
            
            document.addEventListener('keydown', (e) => {
                if(gameState !== 'PLAYING') return;
                if(e.key === "ArrowLeft") setInput('LEFT');
                if(e.key === "ArrowRight") setInput('RIGHT');
            });

            window.addEventListener('resize', onWindowResize);
            loop();
        }

        // --- Core Logic ---

        window.startGame = function() {
            try {
                gameState = 'PLAYING';
                score = 0;
                playerPos = { x: 0, z: 0 };
                isMoving = false;
                currentDirection = null; 
                currentMoveDuration = CONFIG.startSpeed; // Reset speed

                document.getElementById('score').innerText = '0';
                document.getElementById('overlay').classList.add('hidden');
                document.getElementById('left-zone').style.display = 'block';
                document.getElementById('right-zone').style.display = 'block';
                document.getElementById('controls-hint').innerText = "TAP TO START MOVING";

                // Cleanup
                map.forEach((tile) => { if (tile.mesh) scene.remove(tile.mesh); });
                map.clear();
                tweens.length = 0;

                // Reset Hero
                knight.position.set(0, 0, 0);
                knight.rotation.y = Math.PI; 
                knight.visible = true;
                camera.position.set(200, 200, 200);

                // Init World
                for(let x=-2; x<=2; x++){
                    for(let z=-2; z<=2; z++){
                        createTile(x, z, true);
                    }
                }
                generateWorld();

            } catch (err) {
                console.error(err);
            }
        };

        function setInput(dir) {
            currentDirection = dir;
            if (!isMoving && gameState === 'PLAYING') {
                document.getElementById('controls-hint').innerText = ""; 
                nextTurn();
            }
        }

        function nextTurn() {
            if (gameState !== 'PLAYING') return;
            
            if (!currentDirection) {
                isMoving = false;
                return;
            }

            isMoving = true;

            // Increase Speed logic
            if (currentMoveDuration > CONFIG.minSpeed) {
                currentMoveDuration -= CONFIG.acceleration;
            }

            let tx = playerPos.x;
            let tz = playerPos.z;
            let angle = 0;

            if (currentDirection === 'LEFT') {
                tx -= 1;
                angle = Math.PI / 2;
            } else {
                tz -= 1;
                angle = 0;
            }

            const key = `${tx},${tz}`;
            const tile = map.get(key);

            if (!tile || tile.type === 'water') {
                animateMove(tx, tz, angle, 'fall'); 
                return;
            }

            if (tile.content === 'obstacle') {
                knight.lookAt(tx * CONFIG.tileSize, 0, tz * CONFIG.tileSize);
                crashAndBurn(); 
                return;
            }

            if (tile.content === 'enemy') {
                animateAttack(tile, tx, tz, angle);
                return;
            }

            animateMove(tx, tz, angle, 'hop');
        }

        function crashAndBurn() {
            const start = knight.position.clone();
            addTween(100, (p) => {
                knight.position.x = start.x + (Math.random()-0.5)*2;
                knight.position.z = start.z + (Math.random()-0.5)*2;
            }, () => {
                gameOver();
            });
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            isMoving = false;
            currentDirection = null;

            if(score > highScore) highScore = score;
            document.getElementById('highscore').innerText = 'HI: ' + highScore;

            const title = document.getElementById('title-text');
            const desc = document.getElementById('desc-text');
            const btn = document.getElementById('start-btn');
            
            title.innerText = "GAME OVER";
            desc.innerHTML = `Final Score: ${score}<br>Max Speed Reached: ${Math.round(CONFIG.startSpeed - currentMoveDuration)}%`;
            btn.innerText = "RETRY";
            
            document.getElementById('overlay').classList.remove('hidden');
            document.getElementById('left-zone').style.display = 'none';
            document.getElementById('right-zone').style.display = 'none';
        }

        // --- Animations ---

        function animateMove(tx, tz, angle, type) {
            const startX = knight.position.x;
            const startZ = knight.position.z;
            const endX = tx * CONFIG.tileSize;
            const endZ = tz * CONFIG.tileSize;
            
            knight.rotation.y = angle;

            addTween(currentMoveDuration, (p) => {
                knight.position.x = startX + (endX - startX) * p;
                knight.position.z = startZ + (endZ - startZ) * p;

                if(type === 'hop') {
                    knight.position.y = Math.sin(p * Math.PI) * 4;
                } else if (type === 'fall') {
                    knight.position.y = Math.sin(p * Math.PI) * 2 - (p * p * 25);
                }
            }, () => {
                if(type === 'fall') {
                    gameOver();
                } else {
                    playerPos.x = tx;
                    playerPos.z = tz;
                    knight.position.y = 0;
                    score++;
                    document.getElementById('score').innerText = score;
                    generateWorld();
                    nextTurn(); 
                }
            });
        }

        function animateAttack(tile, tx, tz, angle) {
            knight.rotation.y = angle;
            
            // Attack duration scales with move speed so it doesn't desync
            const attackDur = currentMoveDuration * 0.6;

            addTween(attackDur, (p) => {
                swordGroup.rotation.z = -Math.PI/4 - Math.sin(p * Math.PI) * 2;
            }, () => {
                swordGroup.rotation.z = -Math.PI/4;
                spawnParticles(tile.mesh.position, CONFIG.colors.enemy);
                scene.remove(tile.prop);
                tile.content = 'none';
                tile.prop = null;
                
                score += 5; 
                document.getElementById('score').innerText = score;

                animateMove(tx, tz, angle, 'hop');
            });
        }

        // --- World Gen ---

        function generateWorld() {
            const cullDist = 2;
            for(const [k, t] of map) {
                const [tx, tz] = k.split(',').map(Number);
                if(tx > playerPos.x + cullDist || tz > playerPos.z + cullDist) {
                    dropTile(t, k);
                }
            }
            for(let i=1; i<=CONFIG.renderDist; i++) {
                const w = Math.floor(i/1.5) + 1;
                for(let offset = -w; offset <= w; offset++) {
                    createTile(playerPos.x - i, playerPos.z + offset);
                    createTile(playerPos.x + offset, playerPos.z - i);
                }
            }
        }

        function createTile(x, z, isSafe=false) {
            const key = `${x},${z}`;
            if(map.has(key)) return;

            const group = new THREE.Group();
            group.position.set(x * CONFIG.tileSize, 0, z * CONFIG.tileSize);

            const noise = Math.sin(x * 0.45) * Math.cos(z * 0.45);
            const isWater = !isSafe && noise > 0.45;

            let type = isWater ? 'water' : 'ground';
            let content = 'none';
            let prop = null;
            const boxGeo = new THREE.BoxGeometry(CONFIG.tileSize, CONFIG.tileSize, CONFIG.tileSize);

            if(type === 'ground') {
                // Generate a hash-based color tint for uniqueness
                const tint = (Math.abs(Math.sin(x * 1.3 + z * 2.1)) * 0.2) + 0.8; 
                
                const matTop = new THREE.MeshToonMaterial({ color: CONFIG.colors.grass });
                matTop.color.multiplyScalar(tint);
                
                const matSide = new THREE.MeshToonMaterial({ color: CONFIG.colors.dirt });
                matSide.color.multiplyScalar(tint * 0.9); // Slightly darker sides

                const mesh = new THREE.Mesh(boxGeo, [matSide, matSide, matTop, matSide, matSide, matSide]);
                mesh.position.y = -CONFIG.tileSize/2;
                mesh.receiveShadow = true;
                group.add(mesh);

                if(!isSafe) {
                    const r = Math.random();
                    if(r < 0.1) {
                        content = 'obstacle';
                        prop = createTree();
                        group.add(prop);
                    } else if(r < 0.2) {
                        content = 'enemy';
                        prop = createEnemy();
                        group.add(prop);
                    }
                }
            } else {
                const matWater = new THREE.MeshToonMaterial({ color: CONFIG.colors.water, transparent: true, opacity: 0.8 });
                const mesh = new THREE.Mesh(boxGeo, matWater);
                mesh.position.y = -CONFIG.tileSize/2 - 2;
                group.add(mesh);
            }

            scene.add(group);
            map.set(key, { mesh: group, type, content, prop });

            group.scale.set(0,0,0);
            addTween(300, (p) => {
                const s = p >= 1 ? 1 : Math.pow(2, -10*p) * Math.sin((p*10-0.75)*(2*Math.PI)/3) + 1;
                group.scale.set(s,s,s);
            });
        }

        function dropTile(tile, key) {
            map.delete(key);
            const sy = tile.mesh.position.y;
            addTween(300, (p) => {
                tile.mesh.position.y = sy - (p*p*40);
            }, () => scene.remove(tile.mesh));
        }

        // --- Assets ---

        function createHero() {
            knight = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshToonMaterial({ color: CONFIG.colors.hero }));
            body.position.y = 2; body.castShadow = true; knight.add(body);
            const visor = new THREE.Mesh(new THREE.BoxGeometry(3.5, 1.5, 3.5), new THREE.MeshBasicMaterial({ color: 0x333333 }));
            visor.position.y = 2.5; knight.add(visor);
            
            swordGroup = new THREE.Group();
            swordGroup.position.set(2.5, 2, 0); 
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6 }));
            blade.position.y = 2.5; swordGroup.add(blade);
            const hilt = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.5), new THREE.MeshStandardMaterial({ color: CONFIG.colors.wood }));
            hilt.position.y = 0; swordGroup.add(hilt);
            swordGroup.rotation.z = -Math.PI/4; swordGroup.rotation.x = Math.PI/4;
            knight.add(swordGroup);
            scene.add(knight);
        }

        function createEnemy() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.DodecahedronGeometry(2), new THREE.MeshToonMaterial({ color: CONFIG.colors.enemy }));
            b.position.y = 2; b.castShadow = true; g.add(b);
            const e1 = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:0xffffff}));
            e1.position.set(0.8, 2.5, 1.4); g.add(e1);
            const e2 = e1.clone(); e2.position.set(-0.8, 2.5, 1.4); g.add(e2);
            return g;
        }

        function createTree() {
            const g = new THREE.Group();
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 3, 5), new THREE.MeshToonMaterial({ color: CONFIG.colors.wood }));
            t.position.y = 1.5; t.castShadow = true; g.add(t);
            const l = new THREE.Mesh(new THREE.IcosahedronGeometry(2.5), new THREE.MeshToonMaterial({ color: 0x66bb6a }));
            l.position.y = 4; l.castShadow = true; g.add(l);
            return g;
        }

        function spawnParticles(pos, color) {
            for(let i=0; i<6; i++) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), new THREE.MeshBasicMaterial({color: color}));
                m.position.copy(pos); scene.add(m);
                const v = { x:(Math.random()-0.5)*2, y:Math.random()*2, z:(Math.random()-0.5)*2 };
                addTween(400, (p) => {
                    m.position.x += v.x * 0.2; m.position.y += v.y * 0.2; m.position.z += v.z * 0.2;
                    m.scale.setScalar(1-p); m.rotation.x += 0.2;
                }, () => scene.remove(m));
            }
        }

        // --- System ---

        function addTween(d, u, c) { tweens.push({ s: performance.now(), d: d, u: u, c: c }); }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -CONFIG.camZoom * aspect; camera.right = CONFIG.camZoom * aspect;
            camera.top = CONFIG.camZoom; camera.bottom = -CONFIG.camZoom;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function loop() {
            requestAnimationFrame(loop);
            const now = performance.now();
            for(let i=tweens.length-1; i>=0; i--) {
                const t = tweens[i];
                let p = (now - t.s) / t.d;
                if(p > 1) p = 1;
                t.u(p);
                if(p === 1) { if(t.c) t.c(); tweens.splice(i, 1); }
            }
            const tx = knight.position.x + 200;
            const tz = knight.position.z + 200;
            camera.position.x += (tx - camera.position.x) * 0.1;
            camera.position.z += (tz - camera.position.z) * 0.1;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>


