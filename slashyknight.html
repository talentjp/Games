<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slashy Knight Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        #score-board {
            position: absolute;
            top: 40px; /* Lowered slightly for mobile notches */
            font-size: 40px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        #start-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        h1 { color: #f1c40f; margin: 0 0 10px 0; text-transform: uppercase; font-size: 32px; letter-spacing: 2px; }
        p { color: white; margin: 10px 0; font-size: 18px; }
        
        .btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 10px;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 0 #c0392b;
            transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 0 0 #c0392b; }
        
        .hidden { display: none !important; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">0</div>
        
        <div id="start-screen">
            <h1>Slashy Knight</h1>
            <p>Tap to Turn. Slash Enemies.</p>
            <button class="btn" onclick="startGame()">PLAY</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1>YOU DIED</h1>
            <p>Score: <span id="final-score">0</span></p>
            <button class="btn" onclick="resetGame()">RETRY</button>
        </div>
    </div>

    <div id="canvas-container"></div>

<script>
    // --- CONFIGURATION ---
    const TILE_SIZE = 10;
    const SPEED = 0.8; 
    const VIEW_SIZE = 150; 
    
    // --- GLOBALS ---
    let scene, camera, renderer;
    let player;
    let currentDir = { x: 1, z: 0 };
    let isPlaying = false;
    let isGameOver = false;
    let score = 0;
    
    let tiles = []; 
    let entities = []; 
    let generatedRow = 0; 
    let pathCenter = 0;
    
    function init() {
        const container = document.getElementById('canvas-container');
        
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 100, 250);

        // Camera - Initialize with window dimensions to be safe
        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.OrthographicCamera(
            VIEW_SIZE * aspect / -2, VIEW_SIZE * aspect / 2,
            VIEW_SIZE / 2, VIEW_SIZE / -2,
            1, 1000
        );
        
        camera.position.set(200, 200, 200); 
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        // Moderate shadow map size for mobile stability
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousedown', handleInput);
        document.addEventListener('touchstart', handleInput, {passive: false});

        createPlayer();
        
        // FORCE Initial Resize/Render to ensure screen isn't black on load
        onWindowResize();
        renderer.render(scene, camera);
        
        // Start Loop
        animate();
    }

    function createPlayer() {
        const geometry = new THREE.BoxGeometry(6, 6, 6);
        const material = new THREE.MeshStandardMaterial({ color: 0x3498db });
        player = new THREE.Mesh(geometry, material);
        player.castShadow = true;
        player.receiveShadow = true;
        
        const visorGeo = new THREE.BoxGeometry(6.2, 1.5, 4);
        const visorMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const visor = new THREE.Mesh(visorGeo, visorMat);
        visor.position.y = 1;
        player.add(visor);

        const bladeGeo = new THREE.BoxGeometry(1, 12, 1);
        const bladeMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1, metalness: 0.8, roughness: 0.2 });
        const blade = new THREE.Mesh(bladeGeo, bladeMat);
        blade.position.set(4, 2, 4);
        blade.rotation.x = Math.PI / 2;
        player.add(blade);

        scene.add(player);
        resetPlayer();
    }

    function resetPlayer() {
        player.position.set(0, 3, 0); 
        player.rotation.y = 0;
        currentDir = { x: 1, z: 0 };
        // Reset camera immediately
        camera.position.x = 200;
        camera.position.z = 200;
        camera.lookAt(0,0,0);
    }

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        // Force resize again just to be safe
        onWindowResize();

        // Cleanup
        tiles.forEach(t => scene.remove(t));
        entities.forEach(e => scene.remove(e.mesh));
        tiles = [];
        entities = [];
        
        generatedRow = -5; 
        pathCenter = 0;
        score = 0;
        updateScore();

        resetPlayer();
        
        // Pre-generate
        for(let i=0; i<30; i++) {
            generateNextRow();
        }

        isPlaying = true;
        isGameOver = false;
    }

    function resetGame() {
        startGame();
    }

    function handleInput(e) {
        if (!isPlaying || isGameOver) return;
        if (e.target.closest('button')) return;

        if(e.type === 'touchstart') e.preventDefault();

        if (currentDir.x !== 0) {
            currentDir = { x: 0, z: 1 };
            player.rotation.y = -Math.PI / 2;
        } else {
            currentDir = { x: 1, z: 0 };
            player.rotation.y = 0;
        }
    }

    function generateNextRow() {
        if (Math.random() > 0.5) pathCenter += 1;
        else if (Math.random() > 0.5) pathCenter -= 1;
        if(pathCenter > 5) pathCenter = 5;
        if(pathCenter < -5) pathCenter = -5;

        const xPos = generatedRow * TILE_SIZE;
        const width = 3; 
        
        for (let z = pathCenter - width; z <= pathCenter + width; z++) {
            const zPos = z * TILE_SIZE;
            
            const geometry = new THREE.BoxGeometry(TILE_SIZE, 2, TILE_SIZE);
            const isDark = (generatedRow + z) % 2 === 0;
            const color = isDark ? 0x76d7c4 : 0x48c9b0; 
            
            const material = new THREE.LambertMaterial({ color: color });
            const tile = new THREE.Mesh(geometry, material);
            tile.position.set(xPos, -1, zPos);
            tile.receiveShadow = true;
            scene.add(tile);
            tiles.push(tile);

            if (generatedRow > 5) {
                // Obstacles
                if (Math.random() < 0.1 && Math.abs(z - pathCenter) > 0) {
                    createObstacle(xPos, zPos);
                } 
                // Enemy
                else if (Math.random() < 0.05 && Math.abs(z - pathCenter) <= 1) {
                    createEnemy(xPos, zPos);
                }
            }
        }
        generatedRow++;
    }

    function createObstacle(x, z) {
        const h = Math.random() * 5 + 5;
        const geo = new THREE.BoxGeometry(8, h, 8);
        const mat = new THREE.LambertMaterial({ color: 0x7f8c8d });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true;
        scene.add(mesh);
        entities.push({ mesh: mesh, type: 'obstacle', active: true });
    }

    function createEnemy(x, z) {
        const geo = new THREE.BoxGeometry(6, 6, 6);
        const mat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, 3, z);
        mesh.castShadow = true;
        scene.add(mesh);
        entities.push({ mesh: mesh, type: 'enemy', active: true });
    }

    function animate() {
        requestAnimationFrame(animate);

        // Logic
        if (isPlaying && !isGameOver) {
            player.position.x += currentDir.x * SPEED;
            player.position.z += currentDir.z * SPEED;

            const targetX = player.position.x + 100;
            const targetZ = player.position.z + 100;
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;
            camera.lookAt(player.position.x, 0, player.position.z);

            checkCollisions();

            if (player.position.x > (generatedRow - 20) * TILE_SIZE) {
                generateNextRow();
            }
            if (tiles.length > 500) {
                const oldTile = tiles.shift();
                scene.remove(oldTile);
            }
        }

        // Render (ALWAYS render, even if not playing)
        renderer.render(scene, camera);
    }

    function checkCollisions() {
        const pBox = new THREE.Box3().setFromObject(player);
        pBox.expandByScalar(-1); 

        for (let i = 0; i < entities.length; i++) {
            const e = entities[i];
            if (!e.active) continue;

            const eBox = new THREE.Box3().setFromObject(e.mesh);
            if (pBox.intersectsBox(eBox)) {
                if (e.type === 'enemy') {
                    scene.remove(e.mesh);
                    e.active = false;
                    score += 10;
                    updateScore();
                    player.scale.set(1.2, 0.8, 1.2); 
                    setTimeout(() => player.scale.set(1,1,1), 100);
                } else if (e.type === 'obstacle') {
                    gameOver();
                }
            }
        }

        const raycaster = new THREE.Raycaster();
        raycaster.set(player.position, new THREE.Vector3(0, -1, 0));
        const intersects = raycaster.intersectObjects(tiles);
        
        if (intersects.length === 0 && player.position.y > -5) {
            player.position.y -= 2; 
            if (player.position.y < -10) gameOver();
        }
    }

    function updateScore() {
        document.getElementById('score-board').innerText = score;
    }

    function gameOver() {
        isPlaying = false;
        isGameOver = true;
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function onWindowResize() {
        // Use Window dimensions directly for safety
        const w = window.innerWidth;
        const h = window.innerHeight;
        const aspect = w / h;
        
        camera.left = VIEW_SIZE * aspect / -2;
        camera.right = VIEW_SIZE * aspect / 2;
        camera.top = VIEW_SIZE / 2;
        camera.bottom = VIEW_SIZE / -2;
        camera.updateProjectionMatrix();
        
        renderer.setSize(w, h);
    }

    // Initialize on Window Load to ensure DOM is ready
    window.addEventListener('load', init);

</script>
</body>
</html>
