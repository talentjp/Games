<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxel Quest: Fixed</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* --- Base Settings --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #4fc3f7;
            font-family: 'Fredoka One', cursive;
            touch-action: none; /* Prevents scroll/zoom on game area */
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* --- Touch Zones (Layer 1) --- */
        /* These capture game inputs. Hidden by default. */
        .tap-zone {
            position: absolute;
            top: 0;
            height: 100%;
            width: 50%;
            z-index: 10;
            display: none; /* Crucial: Do not block menu clicks initially */
            /* background: rgba(0,0,0,0.1); /* debug tint */
        }
        #left-zone { left: 0; }
        #right-zone { right: 0; }

        /* --- HUD (Layer 2) --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Click-through */
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        .hud-panel {
            background: #5d4037;
            border: 3px solid #3e2723;
            border-radius: 12px;
            padding: 10px 20px;
            color: white;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
            font-size: 1.5rem;
        }

        #controls-hint {
            text-align: center;
            color: rgba(255,255,255,0.9);
            font-size: 1.2rem;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.2);
            margin-bottom: 40px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* --- Menu Overlay (Layer 3) --- */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 136, 229, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            color: white;
            font-size: 3.5rem;
            margin: 0 0 10px 0;
            text-shadow: 0 6px 0 #0d47a1;
            text-align: center;
        }

        p {
            color: #e3f2fd;
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
        }

        /* Start Button */
        #start-btn {
            background: #7cb342;
            color: white;
            border: none;
            padding: 20px 80px;
            font-size: 2rem;
            border-radius: 50px;
            font-family: 'Fredoka One', cursive;
            box-shadow: 0 8px 0 #558b2f;
            cursor: pointer;
            pointer-events: auto; /* Explicitly enable clicks */
            touch-action: manipulation; /* Allow tap without delay */
            transition: transform 0.1s;
        }

        #start-btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #558b2f;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    
    <!-- Gameplay Inputs -->
    <div id="left-zone" class="tap-zone"></div>
    <div id="right-zone" class="tap-zone"></div>

    <!-- HUD -->
    <div id="ui-layer">
        <div class="top-bar">
            <div class="hud-panel">
                <span>üõ°Ô∏è</span>&nbsp;<span id="score">0</span>
            </div>
            <div class="hud-panel" style="background:#ffb300; border-color:#ff6f00;">
                <span id="highscore">HI: 0</span>
            </div>
        </div>
        
        <div id="controls-hint">
            Tap Left ‚Üñ &nbsp;‚Ä¢&nbsp; Tap Right ‚Üó
        </div>
    </div>

    <!-- Menu Overlay -->
    <div id="overlay">
        <h1 id="title-text">VOXEL QUEST</h1>
        <p id="desc-text">Avoid Obstacles<br>Slash Enemies</p>
        <button id="start-btn" onclick="window.startGame()">PLAY</button>
    </div>

    <script>
        // --- Game Constants ---
        const CONFIG = {
            tileSize: 10,
            camZoom: 45,
            renderDist: 18,
            moveSpeed: 200, // ms duration
            colors: {
                sky: 0x4fc3f7,
                water: 0x29b6f6,
                grass: 0x81c784,
                dirt: 0x5d4037,
                hero: 0xffffff,
                enemy: 0xe53935,
                wood: 0x8d6e63
            }
        };

        // --- Global State ---
        let scene, camera, renderer;
        let knight, swordGroup;
        let gameState = 'MENU';
        let score = 0;
        let highScore = 0;
        let playerPos = { x: 0, z: 0 };
        let isMoving = false;

        // Data Storage
        const map = new Map(); // key "x,z" -> { mesh, type, content, prop }
        const tweens = []; // Active animations

        // --- Initialization ---
        function init() {
            // 1. Scene Setup
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);

            // 2. Camera Setup (Isometric)
            const aspect = window.innerWidth / window.innerHeight;
            const d = CONFIG.camZoom;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 2000);
            
            // "High-Up Diagonal" position looking at center
            camera.position.set(200, 200, 200); 
            camera.lookAt(0, 0, 0);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 4. Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(-50, 150, -50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            const shadowD = 150;
            sun.shadow.camera.left = -shadowD;
            sun.shadow.camera.right = shadowD;
            sun.shadow.camera.top = shadowD;
            sun.shadow.camera.bottom = -shadowD;
            scene.add(sun);

            // 5. Hero
            createHero();

            // 6. Infinite Sea
            const seaGeo = new THREE.PlaneGeometry(3000, 3000);
            const seaMat = new THREE.MeshToonMaterial({ color: CONFIG.colors.water });
            const sea = new THREE.Mesh(seaGeo, seaMat);
            sea.rotation.x = -Math.PI / 2;
            sea.position.y = -20;
            scene.add(sea);

            // 7. Inputs
            // Mobile Touch Zones
            document.getElementById('left-zone').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                handleInput('LEFT');
            });
            document.getElementById('right-zone').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                handleInput('RIGHT');
            });

            // Keyboard
            document.addEventListener('keydown', (e) => {
                if(gameState !== 'PLAYING') return;
                if(e.key === "ArrowLeft") handleInput('LEFT');
                if(e.key === "ArrowRight") handleInput('RIGHT');
            });

            // Resize
            window.addEventListener('resize', onWindowResize);

            // Start Render Loop
            loop();
        }

        // --- Core Game Functions ---

        // Exposed globally for the onclick attribute
        window.startGame = function() {
            try {
                // Logic Reset
                gameState = 'PLAYING';
                score = 0;
                playerPos = { x: 0, z: 0 };
                isMoving = false;
                
                // UI Reset
                document.getElementById('score').innerText = '0';
                document.getElementById('overlay').classList.add('hidden');
                
                // Enable Zones
                document.getElementById('left-zone').style.display = 'block';
                document.getElementById('right-zone').style.display = 'block';

                // World Cleanup
                map.forEach((tile) => {
                    if (tile.mesh) scene.remove(tile.mesh);
                });
                map.clear();
                tweens.length = 0;

                // Hero Reset
                knight.position.set(0, 0, 0);
                knight.rotation.y = Math.PI; // Face forward
                knight.visible = true;

                // Camera Reset
                camera.position.set(200, 200, 200);

                // Generate Safe Start
                for(let x=-2; x<=2; x++){
                    for(let z=-2; z<=2; z++){
                        createTile(x, z, true);
                    }
                }

                // Pre-generate world
                generateWorld();

            } catch (err) {
                console.error("Start Error:", err);
                alert("Error starting game. Please refresh.");
            }
        };

        function gameOver() {
            gameState = 'GAMEOVER';
            
            if(score > highScore) highScore = score;
            document.getElementById('highscore').innerText = 'HI: ' + highScore;

            const title = document.getElementById('title-text');
            const desc = document.getElementById('desc-text');
            const btn = document.getElementById('start-btn');
            
            title.innerText = "GAME OVER";
            desc.innerHTML = `Score: ${score}`;
            btn.innerText = "RETRY";
            
            document.getElementById('overlay').classList.remove('hidden');
            
            // Disable zones so they don't block the menu
            document.getElementById('left-zone').style.display = 'none';
            document.getElementById('right-zone').style.display = 'none';
        }

        function handleInput(dir) {
            if(isMoving) return;

            // ISOMETRIC MAPPING
            // Left Input = Move -X (Up-Left visually)
            // Right Input = Move -Z (Up-Right visually)

            let targetX = playerPos.x;
            let targetZ = playerPos.z;
            let angle = 0;

            if (dir === 'LEFT') {
                targetX -= 1;
                angle = Math.PI / 2;
            } else {
                targetZ -= 1;
                angle = 0;
            }

            const key = `${targetX},${targetZ}`;
            const tile = map.get(key);

            // 1. Check for Holes/Water
            if(!tile || tile.type === 'water') {
                isMoving = true;
                animateMove(targetX, targetZ, angle, 'fall');
                return;
            }

            // 2. Check Obstacles
            if(tile.content === 'obstacle') {
                shakeCamera(); // Blocked
                return;
            }

            // 3. Check Enemies
            if(tile.content === 'enemy') {
                isMoving = true;
                animateAttack(tile, targetX, targetZ, angle);
                return;
            }

            // 4. Move
            isMoving = true;
            animateMove(targetX, targetZ, angle, 'hop');
        }

        // --- Animations ---

        function animateMove(tx, tz, angle, type) {
            const startX = knight.position.x;
            const startZ = knight.position.z;
            const endX = tx * CONFIG.tileSize;
            const endZ = tz * CONFIG.tileSize;
            
            knight.rotation.y = angle;

            addTween(CONFIG.moveSpeed, (p) => {
                knight.position.x = startX + (endX - startX) * p;
                knight.position.z = startZ + (endZ - startZ) * p;

                if(type === 'hop') {
                    knight.position.y = Math.sin(p * Math.PI) * 4;
                } else if (type === 'fall') {
                    knight.position.y = Math.sin(p * Math.PI) * 2 - (p * p * 25);
                }
            }, () => {
                if(type === 'fall') {
                    gameOver();
                } else {
                    playerPos.x = tx;
                    playerPos.z = tz;
                    knight.position.y = 0;
                    score++;
                    document.getElementById('score').innerText = score;
                    generateWorld();
                    isMoving = false;
                }
            });
        }

        function animateAttack(tile, tx, tz, angle) {
            knight.rotation.y = angle;
            
            // Sword Swing
            addTween(150, (p) => {
                swordGroup.rotation.z = -Math.PI/4 - Math.sin(p * Math.PI) * 2;
            }, () => {
                // Kill
                swordGroup.rotation.z = -Math.PI/4;
                spawnParticles(tile.mesh.position, CONFIG.colors.enemy);
                scene.remove(tile.prop);
                tile.content = 'none';
                tile.prop = null;
                
                score += 5;
                document.getElementById('score').innerText = score;

                // Move into space
                animateMove(tx, tz, angle, 'hop');
            });
        }

        function shakeCamera() {
            const start = camera.position.clone();
            addTween(100, (p) => {
                camera.position.x = start.x + (Math.random()-0.5)*2;
                camera.position.z = start.z + (Math.random()-0.5)*2;
            }, () => {
                camera.position.copy(start);
            });
        }

        // --- World Generation ---

        function generateWorld() {
            // Remove old tiles (positive relative to player)
            const cullDist = 2;
            for(const [k, t] of map) {
                const [tx, tz] = k.split(',').map(Number);
                if(tx > playerPos.x + cullDist || tz > playerPos.z + cullDist) {
                    animateDropTile(t, k);
                }
            }

            // Generate new cone ahead (negative relative to player)
            for(let i=1; i<=CONFIG.renderDist; i++) {
                const w = Math.floor(i/1.5) + 1;
                for(let offset = -w; offset <= w; offset++) {
                    createTile(playerPos.x - i, playerPos.z + offset);
                    createTile(playerPos.x + offset, playerPos.z - i);
                }
            }
        }

        function createTile(x, z, isSafe=false) {
            const key = `${x},${z}`;
            if(map.has(key)) return;

            const group = new THREE.Group();
            group.position.set(x * CONFIG.tileSize, 0, z * CONFIG.tileSize);

            // Terrain Noise
            const noise = Math.sin(x * 0.45) * Math.cos(z * 0.45);
            const isWater = !isSafe && noise > 0.45;

            let type = isWater ? 'water' : 'ground';
            let content = 'none';
            let prop = null;

            // Geometry reuse
            const boxGeo = new THREE.BoxGeometry(CONFIG.tileSize, CONFIG.tileSize, CONFIG.tileSize);
            
            if(type === 'ground') {
                const matTop = new THREE.MeshToonMaterial({ color: CONFIG.colors.grass });
                const matSide = new THREE.MeshToonMaterial({ color: CONFIG.colors.dirt });
                const mesh = new THREE.Mesh(boxGeo, [matSide, matSide, matTop, matSide, matSide, matSide]);
                mesh.position.y = -CONFIG.tileSize/2;
                mesh.receiveShadow = true;
                group.add(mesh);

                if(!isSafe) {
                    const r = Math.random();
                    if(r < 0.12) {
                        content = 'obstacle';
                        prop = createTree();
                        group.add(prop);
                    } else if(r < 0.22) {
                        content = 'enemy';
                        prop = createEnemy();
                        group.add(prop);
                    }
                }
            } else {
                const matWater = new THREE.MeshToonMaterial({ color: CONFIG.colors.water, transparent: true, opacity: 0.8 });
                const mesh = new THREE.Mesh(boxGeo, matWater);
                mesh.position.y = -CONFIG.tileSize/2 - 2;
                group.add(mesh);
            }

            scene.add(group);
            map.set(key, { mesh: group, type, content, prop });

            // Pop In
            group.scale.set(0,0,0);
            addTween(300, (p) => {
                const s = p >= 1 ? 1 : Math.pow(2, -10*p) * Math.sin((p*10-0.75)*(2*Math.PI)/3) + 1;
                group.scale.set(s,s,s);
            });
        }

        function animateDropTile(tile, key) {
            map.delete(key);
            const sy = tile.mesh.position.y;
            addTween(300, (p) => {
                tile.mesh.position.y = sy - (p*p*40);
            }, () => scene.remove(tile.mesh));
        }

        // --- Assets ---

        function createHero() {
            knight = new THREE.Group();

            // Body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 4, 4),
                new THREE.MeshToonMaterial({ color: CONFIG.colors.hero })
            );
            body.position.y = 2;
            body.castShadow = true;
            knight.add(body);

            // Visor
            const visor = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 1.5, 3.5),
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            visor.position.y = 2.5;
            knight.add(visor);

            // Sword
            swordGroup = new THREE.Group();
            swordGroup.position.set(2.5, 2, 0); 
            
            const blade = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 4, 0.5),
                new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6 })
            );
            blade.position.y = 2.5;
            swordGroup.add(blade);
            
            const hilt = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.5, 1.5),
                new THREE.MeshStandardMaterial({ color: CONFIG.colors.wood })
            );
            hilt.position.y = 0;
            swordGroup.add(hilt);

            swordGroup.rotation.z = -Math.PI/4;
            swordGroup.rotation.x = Math.PI/4;
            knight.add(swordGroup);

            scene.add(knight);
        }

        function createEnemy() {
            const g = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.DodecahedronGeometry(2),
                new THREE.MeshToonMaterial({ color: CONFIG.colors.enemy })
            );
            body.position.y = 2;
            body.castShadow = true;
            g.add(body);
            // Eyes
            const eye = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:0xffffff}));
            eye.position.set(0.8, 2.5, 1.4);
            g.add(eye);
            const eye2 = eye.clone();
            eye2.position.set(-0.8, 2.5, 1.4);
            g.add(eye2);
            return g;
        }

        function createTree() {
            const g = new THREE.Group();
            const t = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1.2, 3, 5),
                new THREE.MeshToonMaterial({ color: CONFIG.colors.wood })
            );
            t.position.y = 1.5;
            t.castShadow = true;
            g.add(t);
            const l = new THREE.Mesh(
                new THREE.IcosahedronGeometry(2.5),
                new THREE.MeshToonMaterial({ color: 0x66bb6a })
            );
            l.position.y = 4;
            l.castShadow = true;
            g.add(l);
            return g;
        }

        function spawnParticles(pos, color) {
            for(let i=0; i<6; i++) {
                const m = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8,0.8,0.8),
                    new THREE.MeshBasicMaterial({color: color})
                );
                m.position.copy(pos);
                scene.add(m);
                const v = { x:(Math.random()-0.5)*2, y:Math.random()*2, z:(Math.random()-0.5)*2 };
                addTween(400, (p) => {
                    m.position.x += v.x * 0.2;
                    m.position.y += v.y * 0.2;
                    m.position.z += v.z * 0.2;
                    m.scale.setScalar(1-p);
                    m.rotation.x += 0.2;
                }, () => scene.remove(m));
            }
        }

        // --- System ---

        function addTween(duration, update, complete) {
            tweens.push({ s: performance.now(), d: duration, u: update, c: complete });
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -CONFIG.camZoom * aspect;
            camera.right = CONFIG.camZoom * aspect;
            camera.top = CONFIG.camZoom;
            camera.bottom = -CONFIG.camZoom;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function loop() {
            requestAnimationFrame(loop);
            const now = performance.now();

            // Tweens
            for(let i=tweens.length-1; i>=0; i--) {
                const t = tweens[i];
                const e = now - t.s;
                let p = e / t.d;
                if(p > 1) p = 1;
                t.u(p);
                if(p === 1) {
                    if(t.c) t.c();
                    tweens.splice(i, 1);
                }
            }

            // Smooth Camera Follow
            // Always offset +200,+200 from player
            const targetX = knight.position.x + 200;
            const targetZ = knight.position.z + 200;
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;

            renderer.render(scene, camera);
        }

        // Boot
        init();

    </script>
</body>
</html>


