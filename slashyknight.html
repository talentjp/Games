<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slashy Knight</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        #score-board {
            position: absolute;
            top: 40px;
            font-size: 50px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        #start-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            border: 2px solid white;
        }

        h1 { color: #f1c40f; margin: 0 0 15px 0; text-transform: uppercase; font-size: 36px; letter-spacing: 2px; }
        p { color: white; margin: 10px 0; font-size: 18px; line-height: 1.5; }
        
        .btn {
            background: #e74c3c;
            color: white;
            border: 3px solid #c0392b;
            padding: 15px 40px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 20px;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 6px 0 #922b21;
            transition: transform 0.1s;
        }
        .btn:active { transform: translateY(6px); box-shadow: 0 0 0 #922b21; }
        
        .hidden { display: none !important; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">0</div>
        
        <div id="start-screen">
            <h1>Slashy Knight</h1>
            <p>Tap to Turn.<br>Smash Enemies.<br>Don't fall.</p>
            <button class="btn" onclick="startGame()">PLAY</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1>YOU DIED</h1>
            <p>Score: <span id="final-score">0</span></p>
            <button class="btn" onclick="resetGame()">RETRY</button>
        </div>
    </div>

    <div id="canvas-container"></div>

<script>
    // --- CONFIGURATION ---
    const TILE_SIZE = 10;
    const SPEED = 0.9; 
    const VIEW_SIZE = 140; // Zoom level
    
    // --- GLOBALS ---
    let scene, camera, renderer;
    let player;
    let currentDir = { x: 1, z: 0 };
    let isPlaying = false;
    let isGameOver = false;
    let score = 0;
    
    // World Objects
    let tiles = []; 
    let entities = []; 
    let generatedRow = 0; 
    let pathCenter = 0;
    
    function init() {
        const container = document.getElementById('canvas-container');
        
        // 1. Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        // FIX: Increased fog distance so objects aren't invisible
        scene.fog = new THREE.Fog(0x87CEEB, 300, 600); 

        // 2. Camera
        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.OrthographicCamera(
            VIEW_SIZE * aspect / -2, VIEW_SIZE * aspect / 2,
            VIEW_SIZE / 2, VIEW_SIZE / -2,
            1, 1000
        );
        
        // Isometric View position
        camera.position.set(100, 100, 100); 
        camera.lookAt(0, 0, 0);

        // 3. Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 4. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // 5. Handlers
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousedown', handleInput);
        document.addEventListener('touchstart', handleInput, {passive: false});

        // 6. Setup Initial World
        createPlayer();
        
        // Generate a starting floor so it's not empty
        generatedRow = -5;
        for(let i=0; i<15; i++) {
            generateNextRow(false); // false = no enemies yet
        }

        // Render once immediately
        onWindowResize();
        renderer.render(scene, camera);
        
        animate();
    }

    function createPlayer() {
        if(player) scene.remove(player);

        // Main Body
        const geometry = new THREE.BoxGeometry(6, 6, 6);
        const material = new THREE.MeshStandardMaterial({ color: 0x3498db });
        player = new THREE.Mesh(geometry, material);
        player.castShadow = true;
        player.receiveShadow = true;
        
        // Visor
        const visor = new THREE.Mesh(
            new THREE.BoxGeometry(6.2, 1.5, 4),
            new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        visor.position.y = 1;
        player.add(visor);

        // Sword
        const blade = new THREE.Mesh(
            new THREE.BoxGeometry(1, 12, 1),
            new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        blade.position.set(4, 2, 4);
        blade.rotation.x = Math.PI / 2;
        player.add(blade);

        scene.add(player);
        resetPlayerParams();
    }

    function resetPlayerParams() {
        player.position.set(0, 3, 0); 
        player.rotation.y = 0;
        currentDir = { x: 1, z: 0 };
        
        // Reset Camera
        camera.position.set(100, 100, 100);
        camera.lookAt(0,0,0);
    }

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        // Clear old world completely
        tiles.forEach(t => scene.remove(t));
        entities.forEach(e => scene.remove(e.mesh));
        tiles = [];
        entities = [];
        
        score = 0;
        generatedRow = -5; 
        pathCenter = 0;
        updateScore();

        resetPlayerParams();
        
        // Generate new path
        for(let i=0; i<40; i++) {
            generateNextRow(i > 10); // Start spawning enemies after 10 rows
        }

        isPlaying = true;
        isGameOver = false;
    }

    function resetGame() {
        startGame();
    }

    function handleInput(e) {
        if (!isPlaying || isGameOver) return;
        if (e.target.closest('button')) return;

        if(e.type === 'touchstart') e.preventDefault();

        // 90 degree turn logic
        if (currentDir.x !== 0) {
            currentDir = { x: 0, z: 1 };
            player.rotation.y = -Math.PI / 2;
        } else {
            currentDir = { x: 1, z: 0 };
            player.rotation.y = 0;
        }
    }

    function generateNextRow(canSpawn = true) {
        // Winding path logic
        if (Math.random() > 0.5) pathCenter += 1;
        else if (Math.random() > 0.5) pathCenter -= 1;
        
        // Keep path bounds
        if(pathCenter > 6) pathCenter = 6;
        if(pathCenter < -6) pathCenter = -6;

        const xPos = generatedRow * TILE_SIZE;
        const width = 3; // Path width
        
        for (let z = pathCenter - width; z <= pathCenter + width; z++) {
            const zPos = z * TILE_SIZE;
            
            // Checkerboard Grass
            const isDark = (generatedRow + z) % 2 === 0;
            const color = isDark ? 0x76d7c4 : 0x48c9b0; 
            
            const tile = new THREE.Mesh(
                new THREE.BoxGeometry(TILE_SIZE, 2, TILE_SIZE),
                new THREE.LambertMaterial({ color: color })
            );
            tile.position.set(xPos, -1, zPos);
            tile.receiveShadow = true;
            scene.add(tile);
            tiles.push(tile);

            if (canSpawn) {
                const distFromCenter = Math.abs(z - pathCenter);
                
                // Obstacles (Trees/Rocks) - Spawn on edges of path
                if (distFromCenter >= 2 && Math.random() < 0.2) {
                    createObstacle(xPos, zPos);
                } 
                // Enemies - Spawn directly on path
                else if (distFromCenter <= 1 && Math.random() < 0.1) {
                    createEnemy(xPos, zPos);
                }
            }
        }
        generatedRow++;
    }

    function createObstacle(x, z) {
        const h = Math.random() * 8 + 4;
        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(8, h, 8),
            new THREE.LambertMaterial({ color: 0x7f8c8d })
        );
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true;
        scene.add(mesh);
        entities.push({ mesh: mesh, type: 'obstacle', active: true });
    }

    function createEnemy(x, z) {
        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(6, 6, 6),
            new THREE.MeshStandardMaterial({ color: 0xe74c3c }) // Red
        );
        mesh.position.set(x, 3, z);
        mesh.castShadow = true;
        scene.add(mesh);
        entities.push({ mesh: mesh, type: 'enemy', active: true });
    }

    function animate() {
        requestAnimationFrame(animate);

        if (isPlaying && !isGameOver) {
            // Move Player
            player.position.x += currentDir.x * SPEED;
            player.position.z += currentDir.z * SPEED;

            // Camera Follow
            const targetX = player.position.x + 100;
            const targetZ = player.position.z + 100;
            // Smooth lerp
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;
            camera.lookAt(player.position.x, 0, player.position.z);

            checkCollisions();

            // Gen new rows
            if (player.position.x > (generatedRow - 25) * TILE_SIZE) {
                generateNextRow(true);
            }
            
            // Cleanup old rows
            if (tiles.length > 400) {
                const oldTile = tiles.shift();
                scene.remove(oldTile);
            }
        }

        renderer.render(scene, camera);
    }

    function checkCollisions() {
        // Player Box
        const pBox = new THREE.Box3().setFromObject(player);
        pBox.expandByScalar(-1.5); // Forgive small overlaps

        // 1. Entity Checks
        for (let i = 0; i < entities.length; i++) {
            const e = entities[i];
            if (!e.active) continue;

            const eBox = new THREE.Box3().setFromObject(e.mesh);
            if (pBox.intersectsBox(eBox)) {
                if (e.type === 'enemy') {
                    // Kill
                    scene.remove(e.mesh);
                    e.active = false;
                    score += 10;
                    updateScore();
                    // Visual Pop
                    player.scale.set(1.4, 0.6, 1.4); 
                    setTimeout(() => player.scale.set(1,1,1), 150);
                } else if (e.type === 'obstacle') {
                    // Die
                    gameOver();
                }
            }
        }

        // 2. Falling Check (Raycast down)
        const raycaster = new THREE.Raycaster();
        raycaster.set(player.position, new THREE.Vector3(0, -1, 0));
        const intersects = raycaster.intersectObjects(tiles);
        
        if (intersects.length === 0 && player.position.y > -5) {
            // Fall
            player.position.y -= 1.5; 
            if (player.position.y < -15) gameOver();
        }
    }

    function updateScore() {
        document.getElementById('score-board').innerText = score;
    }

    function gameOver() {
        isPlaying = false;
        isGameOver = true;
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function onWindowResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const aspect = w / h;
        
        camera.left = VIEW_SIZE * aspect / -2;
        camera.right = VIEW_SIZE * aspect / 2;
        camera.top = VIEW_SIZE / 2;
        camera.bottom = VIEW_SIZE / -2;
        camera.updateProjectionMatrix();
        
        renderer.setSize(w, h);
    }
    
    // Start
    window.addEventListener('load', init);

</script>
</body>
</html>
