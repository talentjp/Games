<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Poly-Mini: Browser Strategy</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            overflow: hidden;
            user-select: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 24px; text-shadow: 2px 2px 0 #000; }
        #ui-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            background: #34495e;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 400px;
            justify-content: space-between;
            align-items: center;
        }
        .stat { font-weight: bold; font-size: 18px; }
        .star-icon { color: #f1c40f; }
        #game-container {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            border: 4px solid #7f8c8d;
            border-radius: 4px;
            cursor: pointer;
        }
        canvas { display: block; background-color: #8fbcdb; }
        button {
            background-color: #e67e22;
            border: none;
            color: white;
            padding: 8px 16px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 0 #d35400;
            transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #d35400; }
        button:disabled { background-color: #95a5a6; box-shadow: none; cursor: not-allowed; transform: none; }
        
        #action-menu {
            position: absolute;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            display: none;
            flex-direction: column;
            gap: 5px;
            pointer-events: none; /* Let clicks pass through to logic handler if needed, but handled by JS */
            z-index: 10;
        }
        .action-btn {
            pointer-events: auto;
            background: #27ae60;
            box-shadow: 0 3px 0 #219150;
            font-size: 14px;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>

    <h1>Poly-Mini</h1>

    <div id="ui-bar">
        <div class="stat"><span class="star-icon">★</span> <span id="stars-display">0</span></div>
        <div class="stat">Turn: <span id="turn-display">1</span></div>
        <button id="end-turn-btn">End Turn</button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div id="action-menu">
            <button class="action-btn" id="train-warrior">Train Warrior (2★)</button>
        </div>
        <div id="message">
            <h2 id="msg-title">Victory!</h2>
            <button onclick="initGame()">Play Again</button>
        </div>
    </div>

<script>
/**
 * POLY-MINI GAME ENGINE
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiStars = document.getElementById('stars-display');
const uiTurn = document.getElementById('turn-display');
const btnEndTurn = document.getElementById('end-turn-btn');
const actionMenu = document.getElementById('action-menu');
const btnTrain = document.getElementById('train-warrior');
const msgBox = document.getElementById('message');
const msgTitle = document.getElementById('msg-title');

// --- Constants ---
const GRID_SIZE = 10;
const TILE_SIZE = 60;
const VIEW_OFFSET_X = 0;
const VIEW_OFFSET_Y = 0;

const COLORS = {
    WATER: '#4fa3d1',
    LAND: '#2ecc71',
    MOUNTAIN: '#95a5a6',
    HIGHLIGHT: 'rgba(255, 255, 255, 0.4)',
    ATTACK: 'rgba(231, 76, 60, 0.6)',
    P1: '#3498db', // Blue
    P2: '#e74c3c'  // Red
};

const TERRAIN = { WATER: 0, LAND: 1, MOUNTAIN: 2 };
const UNIT_TYPE = { WARRIOR: 'warrior' };

// --- Game State ---
let map = [];
let units = [];
let cities = [];
let particles = [];
let currentPlayer = 1; // 1 = Human, 2 = AI
let stars = 5;
let turnCount = 1;
let selectedUnit = null;
let selectedCity = null;
let isGameOver = false;

// --- Initialization ---

function initGame() {
    map = [];
    units = [];
    cities = [];
    particles = [];
    currentPlayer = 1;
    stars = 5;
    turnCount = 1;
    selectedUnit = null;
    selectedCity = null;
    isGameOver = false;
    msgBox.style.display = 'none';
    
    // Generate Map
    for(let y=0; y<GRID_SIZE; y++) {
        let row = [];
        for(let x=0; x<GRID_SIZE; x++) {
            // Simple island generation logic
            let dist = Math.sqrt((x-4.5)**2 + (y-4.5)**2);
            let type = (dist < 4 && Math.random() > 0.2) ? TERRAIN.LAND : TERRAIN.WATER;
            if (type === TERRAIN.LAND && Math.random() < 0.15) type = TERRAIN.MOUNTAIN;
            
            row.push({ x, y, type, owner: 0 });
        }
        map.push(row);
    }

    // Ensure start positions are land
    map[1][1].type = TERRAIN.LAND;
    map[GRID_SIZE-2][GRID_SIZE-2].type = TERRAIN.LAND;

    // Spawn Cities (Capitals)
    addCity(1, 1, 1); // Player
    addCity(GRID_SIZE-2, GRID_SIZE-2, 2); // Enemy

    // Add some neutral villages
    for(let i=0; i<4; i++) {
        let rx = Math.floor(Math.random() * (GRID_SIZE-2)) + 1;
        let ry = Math.floor(Math.random() * (GRID_SIZE-2)) + 1;
        if(map[ry][rx].type === TERRAIN.LAND && !getCityAt(rx, ry)) {
            addCity(rx, ry, 0); // Neutral
        }
    }

    // Spawn Initial Units
    addUnit(1, 1, 1, UNIT_TYPE.WARRIOR);
    addUnit(GRID_SIZE-2, GRID_SIZE-2, 2, UNIT_TYPE.WARRIOR);

    updateUI();
    draw();
}

// --- Logic Helpers ---

function addCity(x, y, owner) {
    cities.push({ x, y, owner, level: 1 });
    map[y][x].owner = owner; // Territory
}

function getCityAt(x, y) {
    return cities.find(c => c.x === x && c.y === y);
}

function addUnit(x, y, owner, type) {
    units.push({
        id: Math.random(),
        x, y, owner, type,
        hp: 10, maxHp: 10,
        moved: false, attacked: false
    });
}

function getUnitAt(x, y) {
    return units.find(u => u.x === x && u.y === y);
}

function getTile(x, y) {
    if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return null;
    return map[y][x];
}

function dist(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

// --- Interaction ---

canvas.addEventListener('mousedown', (e) => {
    if (isGameOver || currentPlayer !== 1) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    const gx = Math.floor(mx / TILE_SIZE);
    const gy = Math.floor(my / TILE_SIZE);

    handleGridClick(gx, gy);
});

function handleGridClick(x, y) {
    const unitClicked = getUnitAt(x, y);
    const cityClicked = getCityAt(x, y);
    
    actionMenu.style.display = 'none'; // Hide menu by default

    // 1. If we have a unit selected, try to move/attack
    if (selectedUnit) {
        if (selectedUnit === unitClicked) {
            selectedUnit = null; // Deselect
            draw();
            return;
        }

        const d = dist(selectedUnit, {x, y});
        
        // Attack?
        if (unitClicked && unitClicked.owner !== 1 && d === 1 && !selectedUnit.attacked) {
            combat(selectedUnit, unitClicked);
            selectedUnit = null;
            draw();
            return;
        }
        
        // Move?
        if (!unitClicked && d === 1 && getTile(x, y).type !== TERRAIN.WATER && !selectedUnit.moved) {
            moveUnit(selectedUnit, x, y);
            selectedUnit = null;
            draw();
            return;
        }
    }

    // 2. Select a friendly unit
    if (unitClicked && unitClicked.owner === 1) {
        if (!unitClicked.moved || !unitClicked.attacked) {
            selectedUnit = unitClicked;
            selectedCity = null;
        }
    } 
    // 3. Select a friendly city (to spawn)
    else if (cityClicked && cityClicked.owner === 1 && !unitClicked) {
        selectedUnit = null;
        selectedCity = cityClicked;
        
        // Show spawn menu
        const screenX = x * TILE_SIZE + 20;
        const screenY = y * TILE_SIZE - 10;
        showActionMenu(screenX, screenY);
    } 
    else {
        selectedUnit = null;
        selectedCity = null;
    }
    
    draw();
}

function showActionMenu(x, y) {
    actionMenu.style.left = x + 'px';
    actionMenu.style.top = y + 'px';
    actionMenu.style.display = 'flex';
    
    // Check funds
    btnTrain.disabled = stars < 2;
    btnTrain.innerHTML = `Train Warrior (2★)`;
    btnTrain.onclick = () => {
        if (stars >= 2 && selectedCity) {
            stars -= 2;
            addUnit(selectedCity.x, selectedCity.y, 1, UNIT_TYPE.WARRIOR);
            // Unit starts exhausted on turn created
            const newUnit = getUnitAt(selectedCity.x, selectedCity.y);
            newUnit.moved = true; 
            newUnit.attacked = true;
            
            selectedCity = null;
            actionMenu.style.display = 'none';
            updateUI();
            draw();
        }
    };
}

function moveUnit(unit, x, y) {
    unit.x = x;
    unit.y = y;
    unit.moved = true;
    
    // Capture Logic
    const city = getCityAt(x, y);
    if (city && city.owner !== unit.owner) {
        city.owner = unit.owner;
        createParticles(x, y, unit.owner === 1 ? COLORS.P1 : COLORS.P2);
        checkWinCondition();
    }
}

function combat(attacker, defender) {
    // Simple damage logic
    const dmg = 4; // Flat damage for simplicity
    defender.hp -= dmg;
    attacker.attacked = true;
    attacker.moved = true; // Attacking consumes move

    createParticles(defender.x, defender.y, '#e74c3c');

    if (defender.hp <= 0) {
        // Kill
        units = units.filter(u => u !== defender);
        // Move attacker into tile (Polytopia style)
        attacker.x = defender.x;
        attacker.y = defender.y;
        
        // Check city capture on kill
        const city = getCityAt(attacker.x, attacker.y);
        if (city && city.owner !== attacker.owner) {
            city.owner = attacker.owner;
            checkWinCondition();
        }
    } else {
        // Retaliation
        if (dist(attacker, defender) <= 1) {
            attacker.hp -= 2;
            if (attacker.hp <= 0) {
                units = units.filter(u => u !== attacker);
            }
        }
    }
}

function checkWinCondition() {
    const enemyCities = cities.filter(c => c.owner === 2).length;
    const playerCities = cities.filter(c => c.owner === 1).length;

    if (enemyCities === 0) endGame(true);
    else if (playerCities === 0) endGame(false);
}

function endGame(win) {
    isGameOver = true;
    msgTitle.innerText = win ? "Victory!" : "Defeat!";
    msgTitle.style.color = win ? COLORS.P1 : COLORS.P2;
    msgBox.style.display = 'block';
}

// --- AI & Turn Management ---

btnEndTurn.addEventListener('click', () => {
    if (currentPlayer !== 1) return;
    
    // Reset Player Units
    units.forEach(u => { if(u.owner === 1) { u.moved = false; u.attacked = false; }});
    
    // Income
    const income = cities.filter(c => c.owner === 1).length; // 1 star per city
    stars += income;
    
    turnCount++;
    currentPlayer = 2; // AI Turn
    selectedUnit = null;
    selectedCity = null;
    actionMenu.style.display = 'none';
    updateUI();
    draw();

    setTimeout(aiTurn, 500);
});

function aiTurn() {
    if (isGameOver) return;

    // 1. AI Spawning
    const aiCities = cities.filter(c => c.owner === 2);
    // AI has infinite money for simplicity, but limited by space
    aiCities.forEach(city => {
        if (!getUnitAt(city.x, city.y) && Math.random() > 0.5) {
            addUnit(city.x, city.y, 2, UNIT_TYPE.WARRIOR);
        }
    });

    // 2. AI Movement / Attack
    const aiUnits = units.filter(u => u.owner === 2);
    
    // Simple coroutine-like delay loop for visual clarity
    let i = 0;
    function processAIUnit() {
        if (i >= aiUnits.length) {
            endAITurn();
            return;
        }

        const unit = aiUnits[i];
        
        // Look for targets
        const targets = units.filter(u => u.owner === 1 && dist(u, unit) === 1);
        if (targets.length > 0) {
            combat(unit, targets[0]); // Attack first available
        } else {
            // Move Logic: Move towards nearest enemy city or unit
            const enemies = units.filter(u => u.owner === 1);
            const enemyCities = cities.filter(c => c.owner === 1);
            let target = null;
            
            if (enemyCities.length > 0) target = enemyCities[0];
            else if (enemies.length > 0) target = enemies[0];

            if (target) {
                // Determine direction
                let dx = 0, dy = 0;
                if (target.x > unit.x) dx = 1;
                else if (target.x < unit.x) dx = -1;
                
                if (target.y > unit.y) dy = 1;
                else if (target.y < unit.y) dy = -1;

                // Try moving X
                let tx = unit.x + dx;
                let ty = unit.y;
                let tile = getTile(tx, ty);
                
                // If X blocked or water, try Y
                if (!tile || tile.type === TERRAIN.WATER || getUnitAt(tx, ty)) {
                    tx = unit.x;
                    ty = unit.y + dy;
                    tile = getTile(tx, ty);
                }

                if (tile && tile.type !== TERRAIN.WATER && !getUnitAt(tx, ty)) {
                    moveUnit(unit, tx, ty);
                }
            }
        }
        
        draw();
        i++;
        setTimeout(processAIUnit, 300);
    }
    
    processAIUnit();
}

function endAITurn() {
    // Reset AI Units
    units.forEach(u => { if(u.owner === 2) { u.moved = false; u.attacked = false; }});
    currentPlayer = 1;
    updateUI();
    draw();
}

function updateUI() {
    uiStars.innerText = stars;
    uiTurn.innerText = turnCount;
    btnEndTurn.disabled = currentPlayer !== 1;
    btnEndTurn.innerText = currentPlayer === 1 ? "End Turn" : "Enemy Turn...";
}

// --- Rendering ---

function draw() {
    // Clear
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Map
    for(let y=0; y<GRID_SIZE; y++) {
        for(let x=0; x<GRID_SIZE; x++) {
            const tile = map[y][x];
            const px = x * TILE_SIZE;
            const py = y * TILE_SIZE;

            // Base Terrain
            ctx.fillStyle = tile.type === TERRAIN.WATER ? COLORS.WATER : COLORS.LAND;
            
            // "3D" effect for land
            if (tile.type !== TERRAIN.WATER) {
                ctx.fillRect(px, py + 5, TILE_SIZE, TILE_SIZE - 5); // Shadow/Side
                ctx.fillStyle = tile.type === TERRAIN.MOUNTAIN ? COLORS.MOUNTAIN : COLORS.LAND;
                
                // Territory Borders (simple tint)
                if (tile.owner === 1) ctx.fillStyle = '#85c1e9'; // Light Blue land
                if (tile.owner === 2) ctx.fillStyle = '#f1948a'; // Light Red land
            }
            
            ctx.fillRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);

            // Mountain Details
            if (tile.type === TERRAIN.MOUNTAIN) {
                ctx.fillStyle = '#7f8c8d';
                ctx.beginPath();
                ctx.moveTo(px + 10, py + TILE_SIZE - 5);
                ctx.lineTo(px + TILE_SIZE/2, py + 10);
                ctx.lineTo(px + TILE_SIZE - 10, py + TILE_SIZE - 5);
                ctx.fill();
            }
        }
    }

    // Draw Cities
    cities.forEach(c => {
        const px = c.x * TILE_SIZE;
        const py = c.y * TILE_SIZE;
        ctx.fillStyle = c.owner === 1 ? COLORS.P1 : (c.owner === 2 ? COLORS.P2 : '#95a5a6');
        
        // City Icon (House)
        ctx.fillRect(px + 15, py + 25, 30, 25);
        ctx.beginPath();
        ctx.moveTo(px + 10, py + 25);
        ctx.lineTo(px + 30, py + 5);
        ctx.lineTo(px + 50, py + 25);
        ctx.fill();
        
        // Capital Star
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.fillText('★', px + 25, py + 40);
    });

    // Draw Units
    units.forEach(u => {
        const px = u.x * TILE_SIZE;
        const py = u.y * TILE_SIZE;
        
        // Unit Body
        ctx.fillStyle = u.owner === 1 ? COLORS.P1 : COLORS.P2;
        
        // Circle base
        ctx.beginPath();
        ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 18, 0, Math.PI*2);
        ctx.fill();
        
        // Outline for active status
        if (u.owner === 1 && !u.moved) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Helmet / Icon
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('⚔️', px + TILE_SIZE/2, py + TILE_SIZE/2);
        
        // HP Bar
        const hpPct = u.hp / u.maxHp;
        ctx.fillStyle = 'red';
        ctx.fillRect(px + 10, py + 5, 40, 4);
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(px + 10, py + 5, 40 * hpPct, 4);
    });

    // Overlays
    if (selectedUnit) {
        // Draw selection ring
        const sx = selectedUnit.x * TILE_SIZE;
        const sy = selectedUnit.y * TILE_SIZE;
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 3;
        ctx.strokeRect(sx, sy, TILE_SIZE, TILE_SIZE);

        // Draw valid moves
        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        dirs.forEach(d => {
            const tx = selectedUnit.x + d[0];
            const ty = selectedUnit.y + d[1];
            const tile = getTile(tx, ty);
            const unitHere = getUnitAt(tx, ty);

            if (tile) {
                // Movement Highlight
                if (!unitHere && tile.type !== TERRAIN.WATER && !selectedUnit.moved) {
                    ctx.fillStyle = COLORS.HIGHLIGHT;
                    ctx.beginPath();
                    ctx.arc(tx * TILE_SIZE + TILE_SIZE/2, ty * TILE_SIZE + TILE_SIZE/2, 10, 0, Math.PI*2);
                    ctx.fill();
                }
                // Attack Highlight
                else if (unitHere && unitHere.owner !== selectedUnit.owner && !selectedUnit.attacked) {
                    ctx.fillStyle = COLORS.ATTACK;
                    ctx.fillRect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        });
    }

    // Selected City Highlight
    if (selectedCity) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(selectedCity.x * TILE_SIZE, selectedCity.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    }
    
    drawParticles();
}

function createParticles(x, y, color) {
    for(let i=0; i<8; i++) {
        particles.push({
            x: x * TILE_SIZE + TILE_SIZE/2,
            y: y * TILE_SIZE + TILE_SIZE/2,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 1.0,
            color: color
        });
    }
}

function drawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
        
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        
        if (p.life <= 0) particles.splice(i, 1);
    }
    
    if (particles.length > 0) requestAnimationFrame(draw);
}

// Start
initGame();

</script>
</body>
</html>
